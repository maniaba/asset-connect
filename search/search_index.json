{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CodeIgniter Asset Connect Documentation","text":"<p>CodeIgniter Asset Connect is a file management library for CodeIgniter 4 that allows you to associate files with any entity in your application.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Associate files with any entity in your application</li> <li>Organize files into collections</li> <li>Store custom properties with your files</li> <li>Easily retrieve and manipulate files</li> <li>Secure asset storage with access control</li> <li>Type-safe API with full IDE support</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>PHP 8.3 or higher</li> <li>CodeIgniter 4.6 or higher</li> <li>CodeIgniter Queue</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Add an asset to a user\n$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;withCustomProperties([\n        'title' =&gt; 'Profile Picture',\n        'description' =&gt; 'User profile picture'\n    ])\n    -&gt;toAssetCollection(ImagesCollection::class);\n\n// Get all assets for a user\n$assets = $user-&gt;getAssets();\n\n// Get assets from a specific collection\n$images = $user-&gt;getAssets(ImagesCollection::class);\n\n// Get the URL to an asset\n$url = $user-&gt;getFirstAsset(ImagesCollection::class)-&gt;getUrl();</code></pre>"},{"location":"#license","title":"License","text":"<p>This library is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"advanced-usage/","title":"Advanced Usage","text":"<p>This page covers advanced usage scenarios for CodeIgniter Asset Connect.</p>"},{"location":"advanced-usage/#custom-asset-collections","title":"Custom Asset Collections","text":"<p>While the basic usage of Asset Connect is sufficient for many applications, you may need more control over how assets are organized and processed. Custom asset collections provide this flexibility.</p>"},{"location":"advanced-usage/#creating-a-custom-asset-collection","title":"Creating a Custom Asset Collection","text":"<p>To create a custom asset collection, create a class that extends <code>DefaultAssetCollection</code> or implements the <code>AssetCollectionDefinitionInterface</code>:</p> <pre><code>class ProductImagesCollection implements AssetCollectionDefinitionInterface, AssetVariantsInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition\n            // Allow specific file extensions using the AssetExtension enum\n            -&gt;allowedExtensions(\n                AssetExtension::JPG,\n                AssetExtension::PNG,\n                AssetExtension::WEBP\n            )\n            // Alternatively, you can use the spread operator with AssetExtension::images()\n            // to allow all image extensions at once:\n            // -&gt;allowedExtensions(...AssetExtension::images())\n            // Allow specific MIME types using the AssetMimeType enum\n            -&gt;allowedMimeTypes(\n                AssetMimeType::IMAGE_JPEG,\n                AssetMimeType::IMAGE_PNG,\n                AssetMimeType::IMAGE_WEBP\n            )\n            // Set maximum file size (in bytes)\n            -&gt;setMaxFileSize(10 * 1024 * 1024) // 10MB\n            // Set a custom path generator for this collection\n            -&gt;setPathGenerator(new CustomPathGenerator());\n    }\n\n    public function checkAuthorization(array|Entity $entity, Asset $asset): bool\n    {\n        // Check if the user is authorized to access this asset\n        // For example, check if the user owns the asset\n        return true;\n    }\n\n    public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void\n    {\n        // Define file variants for this asset collection\n        // For example, create a thumbnail variant\n        if ($asset-&gt;isImage()) {\n            // Create a thumbnail variant\n            // This is just a placeholder - in a real application, you would\n            // use an image manipulation library to create the thumbnail\n            $variants-&gt;assetVariant('thumbnail', static function (AssetVariant $variant, Asset $asset): void {\n                $variant-&gt;writeFile('thumbnail data');\n            });\n        }\n    }\n}</code></pre>"},{"location":"advanced-usage/#using-custom-collections-in-entities","title":"Using Custom Collections in Entities","text":"<p>Once you've created a custom collection, you can use it in your entity's <code>setupAssetConnect</code> method:</p> <pre><code>class Product extends Entity\n{\n    use UseAssetConnectTrait;\n\n    public function setupAssetConnect(SetupAssetCollection $setup): void\n    {\n        // Set the default collection definition\n        // Note: Only one default collection can be set; additional calls will override previous ones\n        $setup-&gt;setDefaultCollectionDefinition(ProductImagesCollection::class);\n\n    }\n}</code></pre>"},{"location":"advanced-usage/#custom-path-generators","title":"Custom Path Generators","text":"<p>Path generators determine how file paths are generated for stored assets. Custom path generators give you control over the directory structure of your stored files.</p>"},{"location":"advanced-usage/#creating-a-custom-path-generator","title":"Creating a Custom Path Generator","text":"<p>To create a custom path generator, implement the <code>PathGeneratorInterface</code>:</p> <pre><code>class YearMonthPathGenerator implements PathGeneratorInterface\n{\n    public function getPath(Asset $asset): string\n    {\n        $date = date('Y/m');\n        $collection = $asset-&gt;getCollection();\n        $entityType = $asset-&gt;entity_type;\n        $entityId = $asset-&gt;entity_id;\n\n        return \"uploads/{$collection}/{$date}/{$entityType}/{$entityId}/{$asset-&gt;file_name}\";\n    }\n}</code></pre>"},{"location":"advanced-usage/#using-custom-path-generators","title":"Using Custom Path Generators","text":"<p>You can use custom path generators in your configuration or in specific asset collections:</p> <pre><code>// In your Config/Asset.php file\nclass Asset extends BaseConfig\n{\n    public string $defaultPathGenerator = YearMonthPathGenerator::class;\n}</code></pre> <p>Or in a specific collection:</p> <pre><code>class ProductImagesCollection implements AssetCollectionDefinitionInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition\n            // Other configuration...\n            -&gt;setPathGenerator(new YearMonthPathGenerator());\n    }\n}</code></pre>"},{"location":"advanced-usage/#working-with-asset-variants","title":"Working with Asset Variants","text":"<p>Asset variants allow you to create different versions of the same asset, such as thumbnails or resized images. Asset Connect provides a flexible way to define and process variants through the <code>AssetVariantsInterface</code>.</p>"},{"location":"advanced-usage/#defining-asset-variants","title":"Defining Asset Variants","text":"<p>You define asset variants in your collection class by implementing the <code>AssetVariantsInterface</code> and its <code>variants</code> method:</p> <pre><code>public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void\n{\n    $variants-&gt;onQueue = true; // Process variants on a queue for better performance\n\n    // Create a thumbnail variant for images\n    if ($asset-&gt;isImage()) {\n        $variants-&gt;assetVariant('thumbnail', static function (AssetVariant $variant, Asset $asset): void {\n            // Use CodeIgniter's image manipulation service\n            $imageService = \\Config\\Services::image();\n            $imageService-&gt;withFile($asset-&gt;path)\n                -&gt;fit(300, 300, 'center')\n                -&gt;save($variant-&gt;path);\n        });\n\n        // Create a medium-sized variant\n        $variants-&gt;assetVariant('medium', static function (AssetVariant $variant, Asset $asset): void {\n            $imageService = \\Config\\Services::image();\n            $imageService-&gt;withFile($asset-&gt;path)\n                -&gt;resize(800, 600, true)\n                -&gt;save($variant-&gt;path);\n        });\n    }\n\n    // Create a preview variant for PDF documents\n    if ($asset-&gt;getMimeType() === 'application/pdf') {\n        $variants-&gt;assetVariant('preview', static function (AssetVariant $variant, Asset $asset): void {\n            // Use a PDF library to create a preview image of the first page\n            // This is just a placeholder - in a real application, you would\n            // use a PDF library like Imagick or a third-party service\n            $variant-&gt;writeFile('PDF preview data');\n        });\n    }\n}</code></pre>"},{"location":"advanced-usage/#queue-processing","title":"Queue Processing","text":"<p>Setting <code>$variants-&gt;onQueue = true</code> tells Asset Connect to process the variants asynchronously using a queue job. This is especially useful for large files or complex processing operations that might take a significant amount of time. The queue job will be processed in the background, allowing your application to continue responding to user requests.</p> <p>To use queue processing, you need to have a queue system set up in your CodeIgniter application. Asset Connect uses CodeIgniter's Queue service, which supports various queue drivers like Database, Redis, and more.</p>"},{"location":"advanced-usage/#accessing-variants","title":"Accessing Variants","text":"<p>Once variants are created, they are stored with the asset and can be accessed through the asset's properties:</p> <pre><code>$asset = $product-&gt;getFirstAsset(ImagesCollection::class);\n\n// Get the URL to a variant\n$thumbnailUrl = $asset-&gt;properties-&gt;fileVariant-&gt;getAssetVariant('thumbnail')-&gt;getUrl();</code></pre>"},{"location":"asset-adder/","title":"Asset Adder","text":"<p>The <code>AssetAdder</code> class is a core component of CodeIgniter Asset Connect that handles the process of adding assets to entities. It provides a fluent interface for configuring assets before they are stored in a collection.</p>"},{"location":"asset-adder/#what-is-assetadder","title":"What is AssetAdder?","text":"<p>When you call the <code>addAsset()</code> method on an entity that uses the <code>UseAssetConnectTrait</code>, it returns an instance of the <code>AssetAdder</code> class. This class allows you to configure various aspects of the asset, such as:</p> <ul> <li>File name and display name</li> <li>Custom properties</li> <li>File name sanitization</li> <li>Order within the collection</li> <li>Whether to preserve the original file</li> </ul> <p>After configuring the asset, you can store it in a collection using the <code>toAssetCollection()</code> method.</p>"},{"location":"asset-adder/#methods","title":"Methods","text":"<p>The <code>AssetAdder</code> class provides several methods for configuring assets before they are stored in a collection.</p>"},{"location":"asset-adder/#preservingoriginal","title":"preservingOriginal","text":"<pre><code>public function preservingOriginal(bool $preserveOriginal = true): self</code></pre> <p>Sets whether to preserve the original file after it has been processed and stored. By default, original files are not preserved.</p> <p>Parameters: - <code>$preserveOriginal</code>: Whether to preserve the original file. Defaults to <code>true</code>.</p> <p>Returns: - The <code>AssetAdder</code> instance for method chaining.</p> <p>Example: <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;preservingOriginal() // Keep the original file\n    -&gt;toAssetCollection();</code></pre></p>"},{"location":"asset-adder/#setorder","title":"setOrder","text":"<pre><code>public function setOrder(int $order): self</code></pre> <p>Sets the order of the asset within the collection. This can be used to control the order in which assets are displayed.</p> <p>Parameters: - <code>$order</code>: The order to set for the asset.</p> <p>Returns: - The <code>AssetAdder</code> instance for method chaining.</p> <p>Example: <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;setOrder(1) // Set the order to 1\n    -&gt;toAssetCollection();</code></pre></p>"},{"location":"asset-adder/#usingfilename","title":"usingFileName","text":"<pre><code>public function usingFileName(string $fileName): self</code></pre> <p>Sets the file name of the asset. This is the name that will be used when storing the file.</p> <p>Parameters: - <code>$fileName</code>: The file name to set for the asset.</p> <p>Returns: - The <code>AssetAdder</code> instance for method chaining.</p> <p>Example: <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;usingFileName('custom-file-name.jpg') // Set a custom file name\n    -&gt;toAssetCollection();</code></pre></p>"},{"location":"asset-adder/#usingname","title":"usingName","text":"<pre><code>public function usingName(string $name): self</code></pre> <p>Sets the display name of the asset. This is the name that will be used when displaying the asset in the application.</p> <p>Parameters: - <code>$name</code>: The display name to set for the asset.</p> <p>Returns: - The <code>AssetAdder</code> instance for method chaining.</p> <p>Example: <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;usingName('Profile Picture') // Set a display name\n    -&gt;toAssetCollection();</code></pre></p>"},{"location":"asset-adder/#sanitizingfilename","title":"sanitizingFileName","text":"<pre><code>public function sanitizingFileName(callable $fileNameSanitizer): self</code></pre> <p>Sets a custom file name sanitizer. This is a callable that takes a string (the file name) and returns a sanitized string.</p> <p>Parameters: - <code>$fileNameSanitizer</code>: A callable that takes a string and returns a sanitized string.</p> <p>Returns: - The <code>AssetAdder</code> instance for method chaining.</p> <p>Example: <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;sanitizingFileName(function (string $fileName): string {\n        return str_replace(['#', '/', '\\\\', ' '], '-', $fileName);\n    }) // Set a custom file name sanitizer\n    -&gt;toAssetCollection();</code></pre></p>"},{"location":"asset-adder/#withcustomproperty","title":"withCustomProperty","text":"<pre><code>public function withCustomProperty(string $key, mixed $value): self</code></pre> <p>Adds a custom property to the asset. Custom properties can be used to store additional information about the asset.</p> <p>Parameters: - <code>$key</code>: The key for the custom property. - <code>$value</code>: The value for the custom property.</p> <p>Returns: - The <code>AssetAdder</code> instance for method chaining.</p> <p>Example: <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;withCustomProperty('title', 'Profile Picture') // Add a custom property\n    -&gt;toAssetCollection();</code></pre></p>"},{"location":"asset-adder/#withcustomproperties","title":"withCustomProperties","text":"<pre><code>public function withCustomProperties(array $customProperties): self</code></pre> <p>Adds multiple custom properties to the asset. Custom properties can be used to store additional information about the asset.</p> <p>Parameters: - <code>$customProperties</code>: An associative array of custom properties.</p> <p>Returns: - The <code>AssetAdder</code> instance for method chaining.</p> <p>Example: <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;withCustomProperties([\n        'title' =&gt; 'Profile Picture',\n        'description' =&gt; 'User profile picture',\n        'tags' =&gt; ['profile', 'user'],\n    ]) // Add multiple custom properties\n    -&gt;toAssetCollection();</code></pre></p>"},{"location":"asset-adder/#toassetcollection","title":"toAssetCollection","text":"<pre><code>public function toAssetCollection(AssetCollectionDefinitionInterface|string|null $collection = null): Asset</code></pre> <p>Stores the asset in the specified collection and returns the stored asset.</p> <p>Parameters: - <code>$collection</code>: The collection to store the asset in. This can be an instance of a class implementing <code>AssetCollectionDefinitionInterface</code>, a string representing the class name, or <code>null</code> to use the default collection.</p> <p>Returns: - The stored <code>Asset</code> instance.</p> <p>Throws: - <code>AssetException</code>: If there is an error storing the asset. - <code>FileException</code>: If there is an error with the file. - <code>InvalidArgumentException</code>: If the collection is invalid. - <code>Throwable</code>: If any other error occurs.</p> <p>Example: <pre><code>// Store in the default collection\n$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;toAssetCollection();\n\n// Store in a specific collection\n$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;toAssetCollection(ImagesCollection::class);</code></pre></p>"},{"location":"asset-adder/#complete-examples","title":"Complete Examples","text":""},{"location":"asset-adder/#basic-usage","title":"Basic Usage","text":"<pre><code>// Add an asset from a file path\n$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;toAssetCollection();</code></pre>"},{"location":"asset-adder/#advanced-usage","title":"Advanced Usage","text":"<pre><code>// Add an asset with various configurations\n$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;usingFileName('custom-file-name.jpg') // Set a custom file name\n    -&gt;usingName('Profile Picture') // Set a display name\n    -&gt;setOrder(1) // Set the order\n    -&gt;preservingOriginal() // Keep the original file\n    -&gt;sanitizingFileName(function (string $fileName): string {\n        return str_replace(['#', '/', '\\\\', ' '], '-', $fileName);\n    }) // Set a custom file name sanitizer\n    -&gt;withCustomProperties([\n        'title' =&gt; 'Profile Picture',\n        'description' =&gt; 'User profile picture',\n        'tags' =&gt; ['profile', 'user'],\n    ]) // Add custom properties\n    -&gt;toAssetCollection(ImagesCollection::class); // Store in a specific collection</code></pre>"},{"location":"asset-adder/#working-with-uploaded-files","title":"Working with Uploaded Files","text":"<p>For handling uploaded files from HTTP requests, use the <code>addAssetFromRequest</code> method described in the next section. This method provides a more convenient and robust way to handle file uploads directly from requests.</p>"},{"location":"asset-adder/#using-addassetfromrequest","title":"Using addAssetFromRequest","text":"<p>The <code>addAssetFromRequest</code> method provides a convenient way to add assets directly from HTTP request files. This method handles the validation and processing of uploaded files automatically.</p> <pre><code>public function addAssetFromRequest(string ...$keyNames): AssetAdderMultiple</code></pre> <p>Parameters: - <code>$keyNames</code>: One or more strings representing the names of the file input fields in the request. At least one key name must be provided.</p> <p>Returns: - An instance of <code>AssetAdderMultiple</code> that allows you to configure and save multiple assets at once.</p> <p>Throws: - <code>AssetException</code>: If there is an error processing the asset. - <code>FileException</code>: If there is an error with the file or if the file is invalid. - <code>InvalidArgumentException</code>: If no key names are provided.</p> <p>Example - Single File Upload: <pre><code>// In a controller method\npublic function uploadProfilePicture()\n{\n    $user = model(User::class)-&gt;find($this-&gt;request-&gt;getPost('user_id'));\n\n    try {\n        // Add assets from the 'profile_picture' field in the request\n        $assetAdders = $user-&gt;addAssetFromRequest('profile_picture')\n            -&gt;forEach(function($uploadedFile, $assetAdder, $fieldName) {\n                $assetAdder\n                    -&gt;usingFileName($uploadedFile-&gt;getRandomName())\n                    -&gt;usingName('Profile Picture')\n                    -&gt;withCustomProperties([\n                        'uploaded_by' =&gt; user_id(),\n                        'uploaded_at' =&gt; date('Y-m-d H:i:s'),\n                    ]);\n            });\n\n        // Convert to assets and store in collection\n        $assets = [];\n        foreach ($assetAdders as $assetAdder) {\n            $assets[] = $assetAdder-&gt;toAssetCollection(ProfilePicturesCollection::class);\n        }\n\n        return redirect()-&gt;to('user/profile')-&gt;with('success', 'Profile picture uploaded successfully.');\n    } catch (\\Exception $e) {\n        return redirect()-&gt;back()-&gt;with('error', $e-&gt;getMessage());\n    }\n}</code></pre></p> <p>Example - Multiple File Upload: <pre><code>// In a controller method\npublic function uploadGalleryImages()\n{\n    $user = model(User::class)-&gt;find($this-&gt;request-&gt;getPost('user_id'));\n\n    try {\n        // Add assets from multiple fields in the request\n        $assets = $user-&gt;addAssetFromRequest('gallery_images', 'additional_images')\n            -&gt;toAssetCollection(GalleryImagesCollection::class);\n\n        return redirect()-&gt;to('user/gallery')-&gt;with('success', count($assets) . ' images uploaded successfully.');\n    } catch (\\Exception $e) {\n        return redirect()-&gt;back()-&gt;with('error', $e-&gt;getMessage());\n    }\n}</code></pre></p> <p>Example - Using forEach with Multiple Files: <pre><code>// In a controller method\npublic function uploadDocuments()\n{\n    $user = model(User::class)-&gt;find($this-&gt;request-&gt;getPost('user_id'));\n\n    try {\n        // Process each uploaded file individually\n        $user-&gt;addAssetFromRequest('documents')\n            -&gt;forEach(function($uploadedFile, $assetAdder, $fieldName) {\n                // Get original file name without extension\n                $originalName = pathinfo($uploadedFile-&gt;getName(), PATHINFO_FILENAME);\n\n                $assetAdder\n                    -&gt;usingName($originalName)\n                    -&gt;withCustomProperty('file_size', $uploadedFile-&gt;getSize())\n                    -&gt;withCustomProperty('mime_type', $uploadedFile-&gt;getMimeType())\n                    -&gt;toAssetCollection(DocumentsCollection::class);\n            });\n\n        return redirect()-&gt;to('user/documents')-&gt;with('success', 'Documents uploaded successfully.');\n    } catch (\\Exception $e) {\n        return redirect()-&gt;back()-&gt;with('error', $e-&gt;getMessage());\n    }\n}</code></pre></p>"},{"location":"asset-adder/#best-practices","title":"Best Practices","text":""},{"location":"asset-adder/#file-name-sanitization","title":"File Name Sanitization","text":"<p>Always sanitize file names to ensure they are safe to use in file systems and URLs. The <code>AssetAdder</code> class provides a default file name sanitizer, but you can override it with your own implementation using the <code>sanitizingFileName</code> method.</p> <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;sanitizingFileName(function (string $fileName): string {\n        // Remove special characters and spaces\n        $fileName = preg_replace('/[^\\w\\.-]/', '-', $fileName);\n        // Convert to lowercase\n        $fileName = strtolower($fileName);\n        // Ensure the file name is not too long\n        $fileName = substr($fileName, 0, 100);\n        return $fileName;\n    })\n    -&gt;toAssetCollection();</code></pre>"},{"location":"asset-adder/#preserving-original-files","title":"Preserving Original Files","text":"<p>By default, the original file is not preserved after it has been processed and stored. If you need to keep the original file, use the <code>preservingOriginal</code> method.</p> <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;preservingOriginal() // Keep the original file\n    -&gt;toAssetCollection();</code></pre>"},{"location":"asset-adder/#custom-properties","title":"Custom Properties","text":"<p>Use custom properties to store additional information about the asset. This can be useful for filtering, sorting, and displaying assets.</p> <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;withCustomProperties([\n        'title' =&gt; 'Profile Picture',\n        'description' =&gt; 'User profile picture',\n        'tags' =&gt; ['profile', 'user'],\n        'visibility' =&gt; 'public',\n        'expires_at' =&gt; date('Y-m-d', strtotime('+30 days')),\n    ])\n    -&gt;toAssetCollection();</code></pre>"},{"location":"asset-adder/#conclusion","title":"Conclusion","text":"<p>The <code>AssetAdder</code> class is a powerful component of CodeIgniter Asset Connect that provides a fluent interface for configuring assets before they are stored in a collection. By using its methods, you can customize various aspects of the asset, such as file name, display name, custom properties, and more.</p>"},{"location":"asset-collections/","title":"Asset Collections","text":"<p>Asset Collections are a core concept in CodeIgniter Asset Connect that allow you to organize your assets into logical groups. This page explains asset collections in detail and documents the interfaces used to define them.</p>"},{"location":"asset-collections/#what-are-asset-collections","title":"What are Asset Collections?","text":"<p>Asset Collections provide a way to group related assets together. For example, you might have a \"profile_pictures\" collection for user profile images, a \"documents\" collection for PDF files, and a \"videos\" collection for video files.</p> <p>Each collection can have its own configuration, such as: - Allowed file types - Maximum file size - Path generation rules - Authorization rules - File variants (e.g., thumbnails)</p>"},{"location":"asset-collections/#registering-asset-collections-required","title":"Registering Asset Collections (Required)","text":"<p>You must register all asset collections in the <code>Config\\Asset.php</code> file with unique identifiers. This is a required step for Asset Connect to function properly:</p> <pre><code>public array $collectionKeyDefinitions = [\n    ProfilePicturesCollection::class =&gt; 'profile_pictures',\n    DocumentsCollection::class =&gt; 'documents',\n    VideosCollection::class =&gt; 'videos',\n];</code></pre> <p>Why this is required:</p> <ul> <li>Collection Identification: Asset Connect uses these identifiers to determine which collection an asset belongs to</li> <li>Database Storage: The identifier is stored in the database as part of the asset record</li> <li>Essential Functionality: Without this registration, Asset Connect cannot process or manage assets for that collection</li> <li>Data Integrity: These mappings are crucial for maintaining proper relationships between assets and their collections</li> </ul> <p>Important: Every asset collection class you create must be registered in the <code>collectionKeyDefinitions</code> array. Failure to register a collection will prevent Asset Connect from working with that collection.</p> <p>For more information, see the Configuration documentation.</p>"},{"location":"asset-collections/#core-interfaces","title":"Core Interfaces","text":"<p>Asset Connect uses several interfaces to define and configure asset collections. Understanding these interfaces is essential for creating custom asset collections.</p>"},{"location":"asset-collections/#assetcollectiondefinitioninterface","title":"AssetCollectionDefinitionInterface","text":"<p>The <code>AssetCollectionDefinitionInterface</code> is the base interface for all asset collections. It defines a single method:</p> <pre><code>public function definition(AssetCollectionSetterInterface $definition): void;</code></pre> <p>This method is where you configure the collection using the provided <code>AssetCollectionSetterInterface</code> instance. For example, you can specify allowed MIME types, maximum file size, and other settings.</p>"},{"location":"asset-collections/#assetvariantsinterface","title":"AssetVariantsInterface","text":"<p>The <code>AssetVariantsInterface</code> allows you to define variants of assets, such as thumbnails or resized images. It defines a single method:</p> <pre><code>public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void;</code></pre> <p>This method is called when an asset is added to the collection. You can use the provided <code>CreateAssetVariantsInterface</code> instance to create variants of the asset.</p>"},{"location":"asset-collections/#authorizableassetcollectiondefinitioninterface","title":"AuthorizableAssetCollectionDefinitionInterface","text":"<p>The <code>AuthorizableAssetCollectionDefinitionInterface</code> extends <code>AssetCollectionDefinitionInterface</code> and adds authorization capabilities to asset collections. It defines an additional method:</p> <pre><code>public function checkAuthorization(array|Entity $entity, Asset $asset): bool;</code></pre> <p>This method is called when an asset is accessed. You can use it to check if the user is authorized to access the asset. For example, you might check if the user owns the asset or has the necessary permissions.</p>"},{"location":"asset-collections/#assetcollectionsetterinterface","title":"AssetCollectionSetterInterface","text":"<p>The <code>AssetCollectionSetterInterface</code> provides methods for configuring asset collections. It's used in the <code>definition</code> method of <code>AssetCollectionDefinitionInterface</code>. It defines the following methods:</p> <pre><code>public function allowedExtensions(AssetExtension|string ...$extensions): static;\npublic function allowedMimeTypes(AssetMimeType|string ...$mimeTypes): static;\npublic function onlyKeepLatest(int $maximumNumberOfItemsInCollection): static;\npublic function setMaxFileSize(float|int $maxFileSize): static;\npublic function singleFileCollection(): static;\npublic function setPathGenerator(PathGeneratorInterface $pathGenerator): static;</code></pre> <p>These methods allow you to: - Specify allowed file extensions - Specify allowed MIME types - Limit the number of items in the collection - Set the maximum file size - Make the collection hold only a single file - Set the path generator for the collection</p>"},{"location":"asset-collections/#createassetvariantsinterface","title":"CreateAssetVariantsInterface","text":"<p>The <code>CreateAssetVariantsInterface</code> is implemented by classes that provide methods for creating asset variants. It's used in the <code>variants</code> method of <code>AssetVariantsInterface</code>. It defines the following method:</p> <pre><code>public function assetVariant(string $name, Closure $closure): ?AssetVariant;</code></pre> <p>This method allows you to create a new asset variant with the given name and closure. The closure receives an <code>AssetVariant</code> and an <code>Asset</code> and is used to define how to process the variant.</p>"},{"location":"asset-collections/#assetvariants-class","title":"AssetVariants Class","text":"<p>The <code>AssetVariants</code> class implements the <code>CreateAssetVariantsInterface</code> and provides methods for creating asset variants. It has a property <code>onQueue</code> that can be set to true to indicate that variants should be processed on a queue:</p> <pre><code>public bool $onQueue = false;</code></pre> <p>When <code>onQueue</code> is set to true, the variants will be processed asynchronously using a queue job, which can improve performance for large files or complex processing.</p>"},{"location":"asset-collections/#creating-custom-asset-collections","title":"Creating Custom Asset Collections","text":"<p>To create a custom asset collection, you need to implement the <code>AssetCollectionDefinitionInterface</code> and optionally the <code>AssetVariantsInterface</code> and/or <code>AuthorizableAssetCollectionDefinitionInterface</code>.</p> <p>Here's an example of a custom asset collection that implements all three interfaces:</p> <pre><code>class ProfilePicturesCollection implements AuthorizableAssetCollectionDefinitionInterface, AssetVariantsInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        // Configure the collection\n        $definition\n            // Allow specific file extensions using the AssetExtension enum\n            -&gt;allowedExtensions(\n                AssetExtension::JPG,\n                AssetExtension::PNG,\n                AssetExtension::GIF\n            )\n            // Alternatively, you can use the spread operator with AssetExtension::images()\n            // to allow all image extensions at once:\n            // -&gt;allowedExtensions(...AssetExtension::images())\n            // Allow specific MIME types using the AssetMimeType enum\n            -&gt;allowedMimeTypes(\n                AssetMimeType::IMAGE_JPEG,\n                AssetMimeType::IMAGE_PNG,\n                AssetMimeType::IMAGE_GIF\n            )\n            // Set maximum file size (in bytes)\n            -&gt;setMaxFileSize(5 * 1024 * 1024) // 5MB\n            // Set a custom path generator for this collection\n            -&gt;setPathGenerator(new CustomPathGenerator());\n    }\n\n    public function checkAuthorization(array|Entity $entity, Asset $asset): bool\n    {\n        // Check if the user is authorized to access this asset\n        // For example, check if the user owns the asset\n        return $entity-&gt;id === $asset-&gt;entity_id;\n    }\n\n    public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void\n    {\n        $variants-&gt;onQueue = true; // Indicates that file variants should be processed on a queue.\n\n        // Create variants of the asset\n        // For example, create a thumbnail\n        if ($asset-&gt;isImage()) {\n            // Create a thumbnail variant\n            $variants-&gt;assetVariant('thumbnail', static function (AssetVariant $variant, Asset $asset): void {\n                // Use an image manipulation library to create the thumbnail\n                $imageService = \\Config\\Services::image();\n                $imageService-&gt;withFile($asset-&gt;path)\n                    -&gt;fit(300, 300, 'center')\n                    -&gt;text('Thumbnail')\n                    -&gt;save($variant-&gt;path);\n\n                // Alternatively, you can use the writeFile method to write the file directly\n                // $variant-&gt;writeFile('thumbnail data');\n            });\n        }\n    }\n}</code></pre>"},{"location":"asset-collections/#using-custom-asset-collections","title":"Using Custom Asset Collections","text":"<p>Once you've created a custom asset collection, you can use it in your entity's <code>setupAssetConnect</code> method:</p> <pre><code>class User extends Entity\n{\n    use UseAssetConnectTrait;\n\n    public function setupAssetConnect(SetupAssetCollection $setup): void\n    {\n        // Register your custom collection\n        $setup-&gt;setDefaultCollectionDefinition(ProfilePicturesCollection::class);\n    }\n}</code></pre> <p>Then you can add assets to the collection:</p> <pre><code>$asset = $user-&gt;addAsset('/path/to/image.jpg')\n    -&gt;withCustomProperties([\n        'title' =&gt; 'Profile Picture',\n        'description' =&gt; 'User profile picture'\n    ])\n    -&gt;toAssetCollection(ProfilePicturesCollection::class);</code></pre> <p>And retrieve assets from the collection:</p> <pre><code>$profilePictures = $user-&gt;getAssets(ProfilePicturesCollection::class);</code></pre>"},{"location":"asset-collections/#default-asset-collection","title":"Default Asset Collection","text":"<p>Asset Connect provides a default asset collection implementation called <code>DefaultAssetCollection</code>. This collection allows all file types and has no size limit. It's used when you don't specify a collection when adding an asset:</p> <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')-&gt;toAssetCollection();</code></pre> <p>You can also use it explicitly:</p> <pre><code>$asset = $user-&gt;addAsset('/path/to/file.jpg')-&gt;toAssetCollection(DefaultAssetCollection::class);</code></pre>"},{"location":"asset-collections/#conclusion","title":"Conclusion","text":"<p>Asset Collections are a powerful feature of CodeIgniter Asset Connect that allow you to organize your assets into logical groups with their own configuration, authorization rules, and file variants. By implementing the interfaces described in this page, you can create custom asset collections tailored to your application's needs.</p>"},{"location":"asset/","title":"Asset","text":"<p>The <code>Asset</code> class is a core component of CodeIgniter Asset Connect that represents a file associated with an entity. It provides methods for accessing and manipulating asset properties, retrieving file information, and managing custom properties.</p>"},{"location":"asset/#what-is-an-asset","title":"What is an Asset?","text":"<p>An Asset in CodeIgniter Asset Connect represents a file that has been associated with an entity in your application. Each Asset contains:</p> <ul> <li>Basic file information (name, path, size, MIME type)</li> <li>Metadata about the asset (custom properties, collection information)</li> <li>Methods for accessing and manipulating the asset</li> </ul> <p>Assets are stored in collections and can be associated with any entity in your application that uses the <code>UseAssetConnectTrait</code>.</p>"},{"location":"asset/#getting-urls-from-assets","title":"Getting URLs from Assets","text":"<p>One of the most common operations is retrieving URLs for assets to display or link to them in your application.</p>"},{"location":"asset/#getting-the-url-for-an-asset","title":"Getting the URL for an Asset","text":"<p>To get the URL for an asset, use the <code>getUrl()</code> method:</p> <pre><code>// Get an asset\n$asset = $user-&gt;getFirstAsset();\n\n// Get the URL to the asset\n$url = $asset-&gt;getUrl();\n// Output: \"https://example.com/assets/images/file.jpg\"</code></pre> <p>This returns a full URL that can be used in your views:</p> <pre><code>&lt;img src=\"&lt;?= $asset-&gt;getUrl() ?&gt;\" alt=\"&lt;?= $asset-&gt;name ?&gt;\"&gt;</code></pre>"},{"location":"asset/#getting-urls-for-asset-variants","title":"Getting URLs for Asset Variants","text":"<p>If your asset has variants (like thumbnails or different sizes of images), you can get the URL for a specific variant by passing the variant name to the <code>getUrl()</code> method:</p> <pre><code>// Get the URL to a thumbnail variant\n$thumbnailUrl = $asset-&gt;getUrl('thumbnail');\n// Output: \"https://example.com/assets/images/variants/thumbnail/file.jpg\"\n\n// Use it in your view\n&lt;img src=\"&lt;?= $asset-&gt;getUrl('thumbnail') ?&gt;\" alt=\"&lt;?= $asset-&gt;name ?&gt; (thumbnail)\"&gt;</code></pre>"},{"location":"asset/#getting-relative-urls","title":"Getting Relative URLs","text":"<p>If you need just the relative path instead of a full URL, use the <code>getUrlRelative()</code> method:</p> <pre><code>// Get the relative URL to the asset\n$relativeUrl = $asset-&gt;getUrlRelative();\n// Output: \"/assets/images/file.jpg\"\n\n// For a variant\n$thumbnailRelativeUrl = $asset-&gt;getUrlRelative('thumbnail');\n// Output: \"/assets/images/variants/thumbnail/file.jpg\"</code></pre>"},{"location":"asset/#getting-temporary-urls","title":"Getting Temporary URLs","text":"<p>For situations where you need to generate a URL that expires after a certain time, use the <code>getTemporaryUrl()</code> method:</p> <pre><code>// Import the Time class\nuse CodeIgniter\\I18n\\Time;\n\n// Get an asset\n$asset = $user-&gt;getFirstAsset();\n\n// Create a temporary URL that expires in 1 hour\n$expiration = Time::now()-&gt;addHours(1);\n$temporaryUrl = $asset-&gt;getTemporaryUrl($expiration);\n// Output: \"https://example.com/assets/abc123def456789/images/file.jpg\"\n\n// Create a temporary URL for a variant\n$thumbnailTemporaryUrl = $asset-&gt;getTemporaryUrl($expiration, 'thumbnail');\n// Output: \"https://example.com/assets/abc123def456789/images/variants/thumbnail/file.jpg\"\n\n// Create a temporary URL that forces download\n$downloadUrl = $asset-&gt;getTemporaryUrl($expiration, null, true);\n// Output: \"https://example.com/assets/abc123def456789/images/file.jpg?download=force\"</code></pre> <p>If you need just the relative path for a temporary URL, use the <code>getTemporaryUrlRelative()</code> method:</p> <pre><code>$expiration = Time::now()-&gt;addHours(1);\n$relativeTemporaryUrl = $asset-&gt;getTemporaryUrlRelative($expiration);\n// Output: \"/assets/abc123def456789/images/file.jpg\"</code></pre>"},{"location":"asset/#properties","title":"Properties","text":"<p>The <code>Asset</code> class has the following properties:</p> Property Type Description <code>id</code> int Unique identifier for the asset <code>entity_type</code> string Type of the entity to which the asset belongs (md5 hash of the class name) <code>entity_id</code> int Identifier for the entity to which the asset belongs <code>collection</code> string Name of the collection to which the asset belongs (md5 hash of the class name) <code>name</code> string Display name of the asset <code>file_name</code> string Name of the file associated with the asset <code>path</code> string Path to the file on the server <code>mime_type</code> string MIME type of the file <code>size</code> int Size of the file in bytes <code>order</code> int Order of the asset in the collection <code>created_at</code> Time Timestamp when the asset was created <code>updated_at</code> Time Timestamp when the asset was last updated <code>deleted_at</code> Time|null Timestamp when the asset was deleted, null if not deleted <code>metadata</code> AssetMetadata Metadata about the asset"},{"location":"asset/#methods","title":"Methods","text":"<p>The <code>Asset</code> class provides several methods for accessing and manipulating asset properties.</p>"},{"location":"asset/#getextension","title":"getExtension","text":"<pre><code>public function getExtension(): string</code></pre> <p>Gets the file extension of the asset.</p> <p>Returns: - The file extension as a string.</p> <p>Throws: - <code>InvalidArgumentException</code>: If the extension cannot be determined.</p> <p>Example: <pre><code>$extension = $asset-&gt;getExtension(); // e.g., \"jpg\"</code></pre></p>"},{"location":"asset/#getpathdirname","title":"getPathDirname","text":"<pre><code>protected function getPathDirname(): string</code></pre> <p>Gets the directory path of the file on the server.</p> <p>Returns: - The directory path as a string.</p> <p>Throws: - <code>InvalidArgumentException</code>: If the path is not set.</p> <p>Example: <pre><code>$dirPath = $asset-&gt;getPathDirname(); // e.g., \"/var/www/uploads/images/\"</code></pre></p>"},{"location":"asset/#getassetcollectiondefinitionclass","title":"getAssetCollectionDefinitionClass","text":"<pre><code>public function getAssetCollectionDefinitionClass(): ?string</code></pre> <p>Gets the class name of the asset collection definition for this asset.</p> <p>Returns: - The class name of the asset collection definition, or null if not set.</p> <p>Throws: - <code>InvalidArgumentException</code>: If the collection class does not exist or does not implement AssetCollectionDefinitionInterface.</p> <p>Example: <pre><code>$collectionClass = $asset-&gt;getAssetCollectionDefinitionClass(); // e.g., \"App\\Collections\\ImagesCollection\"</code></pre></p>"},{"location":"asset/#getassetcollectiondefinition","title":"getAssetCollectionDefinition","text":"<pre><code>public function getAssetCollectionDefinition(...$definitionArguments): ?AssetCollectionDefinitionInterface</code></pre> <p>Gets the asset collection definition for this asset.</p> <p>Parameters: - <code>$definitionArguments</code>: Additional arguments to pass to the collection definition constructor.</p> <p>Returns: - The asset collection definition, or null if not set.</p> <p>Example: <pre><code>$collectionDefinition = $asset-&gt;getAssetCollectionDefinition();</code></pre></p>"},{"location":"asset/#getsubjectentity","title":"getSubjectEntity","text":"<pre><code>public function getSubjectEntity(...$arguments): ?Entity</code></pre> <p>Gets the subject entity which this asset belongs to.</p> <p>Parameters: - <code>$arguments</code>: Arguments to pass to the entity constructor.</p> <p>Returns: - The entity that this asset belongs to, or null if not set.</p> <p>Example: <pre><code>$entity = $asset-&gt;getSubjectEntity();</code></pre></p>"},{"location":"asset/#getsubjectentityclassname","title":"getSubjectEntityClassName","text":"<pre><code>public function getSubjectEntityClassName(): ?string</code></pre> <p>Gets the class name of the subject entity which this asset belongs to.</p> <p>Returns: - The class name of the subject entity, or null if not set.</p> <p>Throws: - <code>InvalidArgumentException</code>: If the entity class does not exist or does not extend Entity.</p> <p>Example: <pre><code>$entityClass = $asset-&gt;getSubjectEntityClassName(); // e.g., \"App\\Models\\User\"</code></pre></p>"},{"location":"asset/#getcustomproperty","title":"getCustomProperty","text":"<pre><code>public function getCustomProperty(string $propertyName): mixed</code></pre> <p>Gets a custom property value.</p> <p>Parameters: - <code>$propertyName</code>: The name of the custom property.</p> <p>Returns: - The value of the custom property, or null if not set.</p> <p>Example: <pre><code>$title = $asset-&gt;getCustomProperty('title'); // e.g., \"Profile Picture\"</code></pre></p>"},{"location":"asset/#setcustomproperty","title":"setCustomProperty","text":"<pre><code>public function setCustomProperty(string $propertyName, mixed $value): static</code></pre> <p>Sets a custom property value.</p> <p>Parameters: - <code>$propertyName</code>: The name of the custom property. - <code>$value</code>: The value to set.</p> <p>Returns: - The Asset instance for method chaining.</p> <p>Example: <pre><code>$asset-&gt;setCustomProperty('title', 'New Profile Picture');</code></pre></p>"},{"location":"asset/#getcustomproperties","title":"getCustomProperties","text":"<pre><code>public function getCustomProperties(): array</code></pre> <p>Gets all custom properties.</p> <p>Returns: - An associative array of custom properties.</p> <p>Example: <pre><code>$properties = $asset-&gt;getCustomProperties();\n// [\n//     'title' =&gt; 'Profile Picture',\n//     'description' =&gt; 'User profile picture',\n//     'tags' =&gt; ['profile', 'user']\n// ]</code></pre></p>"},{"location":"asset/#save","title":"save","text":"<pre><code>public function save(): bool</code></pre> <p>Saves the asset to the database.</p> <p>Returns: - True if the asset was saved successfully, false otherwise.</p> <p>Example: <pre><code>$result = $asset-&gt;save();</code></pre></p>"},{"location":"asset/#getrelativepath","title":"getRelativePath","text":"<pre><code>protected function getRelativePath(): string</code></pre> <p>Gets the relative path of the file in the storage.</p> <p>Returns: - The relative path as a string.</p> <p>Throws: - <code>InvalidArgumentException</code>: If the relative path is not set.</p> <p>Example: <pre><code>$relativePath = $asset-&gt;getRelativePath(); // e.g., \"/uploads/images/profile.jpg\"</code></pre></p>"},{"location":"asset/#download","title":"download","text":"<pre><code>public function download(?string $variantName = null): DownloadResponse</code></pre> <p>Creates a download response for the asset.</p> <p>Parameters: - <code>$variantName</code>: The name of the variant to download, or null for the original asset.</p> <p>Returns: - A DownloadResponse instance.</p> <p>Example: <pre><code>$response = $asset-&gt;download(); // Download the original asset\n$response = $asset-&gt;download('thumbnail'); // Download a thumbnail variant</code></pre></p>"},{"location":"asset/#gethumanreadablesize","title":"getHumanReadableSize","text":"<pre><code>public function getHumanReadableSize(int $precision = 2): string</code></pre> <p>Gets the human-readable size of the asset.</p> <p>Parameters: - <code>$precision</code>: The number of decimal places to include in the formatted size.</p> <p>Returns: - The human-readable size as a string.</p> <p>Example: <pre><code>$size = $asset-&gt;getHumanReadableSize(); // e.g., \"1.25 MB\"</code></pre></p>"},{"location":"asset/#geturl","title":"getUrl","text":"<pre><code>public function getUrl(?string $variantName = null): string</code></pre> <p>Gets the URL to access the asset. See the Getting URLs from Assets section at the beginning of this document for detailed examples.</p> <p>Parameters: - <code>$variantName</code>: The name of the variant to get the URL for, or null for the original asset.</p> <p>Returns: - The URL as a string.</p>"},{"location":"asset/#geturlrelative","title":"getUrlRelative","text":"<pre><code>public function getUrlRelative(?string $variantName = null): string</code></pre> <p>Gets the relative URL to access the asset. See the Getting URLs from Assets section at the beginning of this document for detailed examples.</p> <p>Parameters: - <code>$variantName</code>: The name of the variant to get the URL for, or null for the original asset.</p> <p>Returns: - The relative URL as a string.</p>"},{"location":"asset/#gettemporaryurl","title":"getTemporaryUrl","text":"<pre><code>public function getTemporaryUrl(Time $expiration, ?string $variantName = null, bool $forceDownload = false): string</code></pre> <p>Gets a temporary URL for the asset that expires after the specified time. See the Getting URLs from Assets section at the beginning of this document for detailed examples.</p> <p>Parameters: - <code>$expiration</code>: The time when the URL should expire. - <code>$variantName</code>: The name of the variant to get the URL for, or null for the original asset. - <code>$forceDownload</code>: Whether to force the browser to download the file instead of displaying it.</p> <p>Returns: - The temporary URL as a string.</p>"},{"location":"asset/#gettemporaryurlrelative","title":"getTemporaryUrlRelative","text":"<pre><code>public function getTemporaryUrlRelative(Time $expiration, ?string $variantName = null, bool $forceDownload = false): string</code></pre> <p>Gets a temporary relative URL for the asset that expires after the specified time. See the Getting URLs from Assets section at the beginning of this document for detailed examples.</p> <p>Parameters: - <code>$expiration</code>: The time when the URL should expire. - <code>$variantName</code>: The name of the variant to get the URL for, or null for the original asset. - <code>$forceDownload</code>: Whether to force the browser to download the file instead of displaying it.</p> <p>Returns: - The temporary relative URL as a string.</p>"},{"location":"asset/#isimage","title":"isImage","text":"<pre><code>public function isImage(): bool</code></pre> <p>Checks if the asset is an image.</p> <p>Returns: - True if the asset is an image, false otherwise.</p> <p>Example: <pre><code>if ($asset-&gt;isImage()) {\n    // Do something with the image\n}</code></pre></p>"},{"location":"asset/#isvideo","title":"isVideo","text":"<pre><code>public function isVideo(): bool</code></pre> <p>Checks if the asset is a video.</p> <p>Returns: - True if the asset is a video, false otherwise.</p> <p>Example: <pre><code>if ($asset-&gt;isVideo()) {\n    // Do something with the video\n}</code></pre></p>"},{"location":"asset/#isdocument","title":"isDocument","text":"<pre><code>public function isDocument(): bool</code></pre> <p>Checks if the asset is a document.</p> <p>Returns: - True if the asset is a document, false otherwise.</p> <p>Example: <pre><code>if ($asset-&gt;isDocument()) {\n    // Do something with the document\n}</code></pre></p>"},{"location":"asset/#complete-examples","title":"Complete Examples","text":""},{"location":"asset/#basic-usage","title":"Basic Usage","text":"<pre><code>// Get an asset\n$asset = $user-&gt;getFirstAsset();\n\n// Get basic information\n$id = $asset-&gt;id;\n$name = $asset-&gt;name;\n$fileName = $asset-&gt;file_name;\n$mimeType = $asset-&gt;mime_type;\n$size = $asset-&gt;size;\n$readableSize = $asset-&gt;getHumanReadableSize();\n$extension = $asset-&gt;getExtension();\n\n// Get the URL to the asset\n$url = $asset-&gt;getUrl();\n// Output: \"https://example.com/assets/images/file.jpg\"\n\n// Check the asset type\nif ($asset-&gt;isImage()) {\n    // Handle image asset\n} elseif ($asset-&gt;isVideo()) {\n    // Handle video asset\n} elseif ($asset-&gt;isDocument()) {\n    // Handle document asset\n}</code></pre>"},{"location":"asset/#working-with-custom-properties","title":"Working with Custom Properties","text":"<pre><code>// Get an asset\n$asset = $user-&gt;getFirstAsset();\n\n// Get all custom properties\n$properties = $asset-&gt;getCustomProperties();\n\n// Get a specific custom property\n$title = $asset-&gt;getCustomProperty('title');\n\n// Set a custom property\n$asset-&gt;setCustomProperty('title', 'New Title');\n\n// Save the changes\n$asset-&gt;save();</code></pre>"},{"location":"asset/#downloading-assets","title":"Downloading Assets","text":"<pre><code>// Get an asset\n$asset = $user-&gt;getFirstAsset();\n\n// Create a download response for the asset\n$response = $asset-&gt;download();\n\n// Return the response to trigger the download\nreturn $response;</code></pre>"},{"location":"asset/#working-with-asset-variants","title":"Working with Asset Variants","text":"<pre><code>// Get an asset\n$asset = $user-&gt;getFirstAsset();\n\n// Get the URL to a variant\n$thumbnailUrl = $asset-&gt;getUrl('thumbnail');\n// Output: \"https://example.com/assets/images/variants/thumbnail/file.jpg\"\n\n// Download a variant\n$response = $asset-&gt;download('thumbnail');</code></pre>"},{"location":"asset/#best-practices","title":"Best Practices","text":""},{"location":"asset/#handling-asset-urls","title":"Handling Asset URLs","text":"<p>When displaying assets in your application, always use the <code>getUrl()</code> method to get the URL to the asset. This ensures that the URL is generated correctly based on your application's configuration.</p> <pre><code>&lt;img src=\"&lt;?= $asset-&gt;getUrl() ?&gt;\" alt=\"&lt;?= $asset-&gt;name ?&gt;\"&gt;</code></pre>"},{"location":"asset/#checking-asset-types","title":"Checking Asset Types","text":"<p>Before performing operations specific to certain file types, use the <code>isImage()</code>, <code>isVideo()</code>, and <code>isDocument()</code> methods to check the asset type.</p> <pre><code>if ($asset-&gt;isImage()) {\n    // Display image preview\n    echo '&lt;img src=\"' . $asset-&gt;getUrl() . '\" alt=\"' . $asset-&gt;name . '\"&gt;';\n} elseif ($asset-&gt;isVideo()) {\n    // Display video player\n    echo '&lt;video src=\"' . $asset-&gt;getUrl() . '\" controls&gt;&lt;/video&gt;';\n} elseif ($asset-&gt;isDocument()) {\n    // Display document download link\n    echo '&lt;a href=\"' . $asset-&gt;getUrl() . '\"&gt;Download ' . $asset-&gt;name . '&lt;/a&gt;';\n}</code></pre>"},{"location":"asset/#managing-custom-properties","title":"Managing Custom Properties","text":"<p>Custom properties are a powerful way to store additional information about assets. Use them to store metadata that is specific to your application's needs.</p> <pre><code>// Add custom properties when creating an asset\n$asset = $user-&gt;addAsset('/path/to/file.jpg')\n    -&gt;withCustomProperties([\n        'title' =&gt; 'Profile Picture',\n        'description' =&gt; 'User profile picture',\n        'tags' =&gt; ['profile', 'user'],\n        'visibility' =&gt; 'public',\n        'expires_at' =&gt; date('Y-m-d', strtotime('+30 days')),\n    ])\n    -&gt;toAssetCollection();\n\n// Update custom properties later\n$asset-&gt;setCustomProperty('visibility', 'private');\n$asset-&gt;save();</code></pre>"},{"location":"asset/#conclusion","title":"Conclusion","text":"<p>The <code>Asset</code> class is a fundamental component of CodeIgniter Asset Connect that provides a rich set of methods for working with files associated with entities in your application. By using its methods, you can access file information, manage custom properties, generate URLs, and more.</p>"},{"location":"basic-usage/","title":"Basic Usage","text":"<p>This guide covers the fundamental operations you can perform with CodeIgniter Asset Connect.</p>"},{"location":"basic-usage/#working-with-entities","title":"Working with Entities","text":""},{"location":"basic-usage/#setting-up-an-entity","title":"Setting Up an Entity","text":"<p>To use Asset Connect with an entity, you need to add the <code>UseAssetConnectTrait</code> to your entity class and implement the <code>setupAssetConnect</code> method:</p> <pre><code>class Product extends Entity\n{\n    use UseAssetConnectTrait;\n\n    public function setupAssetConnect(SetupAssetCollection $setup): void\n    {\n        // Set the default collection definition\n        // Note: Only one default collection can be set; additional calls will override previous ones\n        $setup-&gt;setDefaultCollectionDefinition(ImagesCollection::class);\n\n    }\n}\n\n// Example of a custom collection class\nclass ImagesCollection implements AssetCollectionDefinitionInterface, AssetVariantsInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        // Configure the collection using the setter interface\n        $definition\n            // Allow specific file extensions using the AssetExtension enum\n            -&gt;allowedExtensions(\n                AssetExtension::JPG,\n                AssetExtension::PNG,\n                AssetExtension::GIF\n            )\n            // Alternatively, you can use the spread operator with AssetExtension::images()\n            // to allow all image extensions at once:\n            // -&gt;allowedExtensions(...AssetExtension::images())\n            // Allow specific MIME types using the AssetMimeType enum\n            -&gt;allowedMimeTypes(\n                AssetMimeType::IMAGE_JPEG,\n                AssetMimeType::IMAGE_PNG,\n                AssetMimeType::IMAGE_GIF\n            )\n            // Set maximum file size (in bytes)\n            -&gt;setMaxFileSize(5 * 1024 * 1024); // 5MB\n    }\n\n    public function checkAuthorization(array|Entity $entity, Asset $asset): bool\n    {\n        // Check if the user is authorized to access this asset\n        return true;\n    }\n\n    public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void\n    {\n        // Define file variants (e.g., thumbnails)\n    }\n}</code></pre>"},{"location":"basic-usage/#understanding-setupassetcollection-interface","title":"Understanding SetupAssetCollection Interface","text":"<p>The <code>SetupAssetCollection</code> interface provides methods to configure how assets are handled for an entity. Here's an explanation of each method:</p>"},{"location":"basic-usage/#setpathgenerator","title":"setPathGenerator","text":"<pre><code>$setup-&gt;setPathGenerator(CustomPathGenerator::class);</code></pre> <p>This method sets the path generator for the asset collection. The path generator determines how file paths are generated for stored assets. It accepts either an instance of a class implementing <code>PathGeneratorInterface</code> or a string representing the class name.</p>"},{"location":"basic-usage/#setfilenamesanitizer","title":"setFileNameSanitizer","text":"<pre><code>$setup-&gt;setFileNameSanitizer(function (string $fileName): string {\n    return str_replace(['#', '/', '\\\\', ' '], '-', $fileName);\n});</code></pre> <p>This method sets a closure to sanitize file names before they are stored. The closure should accept a string (the file name) and return a sanitized string. This method replaces the default sanitizer.</p>"},{"location":"basic-usage/#setpreserveoriginal","title":"setPreserveOriginal","text":"<pre><code>$setup-&gt;setPreserveOriginal(true);</code></pre> <p>This method determines whether to preserve the original file after it has been processed and stored. By default, original files are not preserved.</p>"},{"location":"basic-usage/#setsubjectprimarykeyattribute","title":"setSubjectPrimaryKeyAttribute","text":"<pre><code>$setup-&gt;setSubjectPrimaryKeyAttribute('user_id');</code></pre> <p>This method sets the primary key attribute for the subject of the asset collection. By default, the system tries to automatically detect it from the model's <code>$primaryKey</code> property, but you can override it with this method.</p>"},{"location":"basic-usage/#autodetectsubjectprimarykeyattribute","title":"autoDetectSubjectPrimaryKeyAttribute","text":"<pre><code>$setup-&gt;autoDetectSubjectPrimaryKeyAttribute(UserModel::class);</code></pre> <p>This method automatically detects the primary key attribute from the specified model class. It's useful when you want to ensure the correct primary key is used without hardcoding it.</p>"},{"location":"basic-usage/#adding-assets","title":"Adding Assets","text":"<p>You can add assets to an entity using the <code>addAsset</code> method:</p> <pre><code>// Add an asset from a file path\n$asset = $product-&gt;addAsset('/path/to/image.jpg')-&gt;toAssetCollection();\n\n// Add an asset to a specific collection\n$asset = $product-&gt;addAsset('/path/to/manual.pdf')\n    -&gt;toAssetCollection(DocumentsCollection::class);\n\n// Add an asset with custom properties\n$asset = $product-&gt;addAsset('/path/to/video.mp4')\n    -&gt;withCustomProperties([\n        'title' =&gt; 'Product Demo',\n        'description' =&gt; 'A demonstration of the product features',\n        'duration' =&gt; '2:30',\n    ])\n    -&gt;toAssetCollection(VideosCollection::class);</code></pre>"},{"location":"basic-usage/#retrieving-assets","title":"Retrieving Assets","text":"<p>You can retrieve assets from an entity using various methods:</p> <pre><code>// Get all assets\n$allAssets = $product-&gt;getAssets();\n\n// Get assets from a specific collection\n$images = $product-&gt;getAssets(ImagesCollection::class);\n\n// Get the first asset\n$firstAsset = $product-&gt;getFirstAsset();\n\n// Get the first asset from a specific collection\n$firstImage = $product-&gt;getFirstAsset(ImagesCollection::class);\n\n// Get the last asset from a specific collection\n$lastDocument = $product-&gt;getLastAsset(DocumentsCollection::class);</code></pre>"},{"location":"basic-usage/#deleting-assets","title":"Deleting Assets","text":"<p>You can delete assets from an entity:</p> <pre><code>// Delete all assets\n$product-&gt;deleteAssets();\n\n// Delete assets from a specific collection\n$product-&gt;deleteAssets(ImagesCollection::class);</code></pre>"},{"location":"basic-usage/#working-with-collections","title":"Working with Collections","text":"<p>Asset collections provide a way to organize your assets into logical groups. You can work with collections directly:</p> <pre><code>// Get a collection\n$imagesCollection = $product-&gt;collection(ImagesCollection::class);\n\n// Add an asset to the collection\n$asset = $imagesCollection-&gt;addAsset('/path/to/image.jpg')-&gt;toAssetCollection();\n\n// Get all assets in the collection\n$images = $imagesCollection-&gt;getAssets();\n\n// Get the first asset in the collection\n$firstImage = $imagesCollection-&gt;getFirstAsset();\n\n// Delete all assets in the collection\n$imagesCollection-&gt;deleteAssets();</code></pre>"},{"location":"basic-usage/#working-with-assets","title":"Working with Assets","text":"<p>The <code>Asset</code> entity provides methods for working with individual assets:</p> <pre><code>// Get an asset\n$asset = $product-&gt;getFirstAsset(ImagesCollection::class);\n\n// Get the absolute path to the asset file\n$path = $asset-&gt;getAbsolutePath();\n\n// Get the URL to the asset file\n$url = $asset-&gt;getUrl();\n\n// Get the custom properties of the asset\n$properties = $asset-&gt;getCustomProperties();\n\n// Get a specific custom property\n$title = $asset-&gt;getCustomProperty('title');\n\n// Get the file name\n$fileName = $asset-&gt;getFileName();\n\n// Get the mime type\n$mimeType = $asset-&gt;getMimeType();\n\n// Get the size in bytes\n$size = $asset-&gt;getSize();\n\n// Get the human-readable size\n$readableSize = $asset-&gt;getHumanReadableSize();\n\n// Check if the asset is an image\nif ($asset-&gt;isImage()) {\n    // Do something with the image\n}\n\n// Check if the asset is a video\nif ($asset-&gt;isVideo()) {\n    // Do something with the video\n}\n\n// Check if the asset is a document\nif ($asset-&gt;isDocument()) {\n    // Do something with the document\n}</code></pre>"},{"location":"basic-usage/#using-enums","title":"Using Enums","text":"<p>Asset Connect provides several enums for working with assets:</p>"},{"location":"basic-usage/#secure-asset-storage","title":"Secure Asset Storage","text":"<p>When you need to store assets in a non-public location (like the \"writable\" folder), you can implement the <code>AuthorizableAssetCollectionDefinitionInterface</code>. This interface adds access control to your asset collections, requiring users to go through a controller to access the files:</p> <pre><code>class SecureDocumentsCollection implements AuthorizableAssetCollectionDefinitionInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        // Configure the collection\n        $definition\n            // Allow specific file extensions using the AssetExtension enum\n            -&gt;allowedExtensions(\n                AssetExtension::PDF,\n                AssetExtension::DOC,\n                AssetExtension::DOCX\n            )\n            // Allow specific MIME types using the AssetMimeType enum\n            -&gt;allowedMimeTypes(\n                AssetMimeType::APPLICATION_PDF,\n                AssetMimeType::APPLICATION_MSWORD,\n                AssetMimeType::APPLICATION_DOCX\n            );\n    }\n\n    public function checkAuthorization(array|Entity $entity, Asset $asset): bool\n    {\n        // Check if the user is authorized to access this asset\n        // For example, check if the user owns the asset or has the right permissions\n        return $entity-&gt;id === $asset-&gt;entity_id;\n    }\n\n    public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void\n    {\n        // No variants needed for documents\n    }\n}</code></pre>"},{"location":"basic-usage/#assetextension","title":"AssetExtension","text":"<pre><code>// Available file extensions (examples)\nAssetExtension::JPG;  // 'jpg'\nAssetExtension::PNG;  // 'png'\nAssetExtension::PDF;  // 'pdf'\nAssetExtension::MP4;  // 'mp4'\n\n// Get all extensions of a specific category\n$imageExtensions = AssetExtension::images(); // Returns array of image extension enums\n$documentExtensions = AssetExtension::documents(); // Returns array of document extension enums\n$videoExtensions = AssetExtension::videos(); // Returns array of video extension enums\n\n// Get more specific subcategories\n$vectorGraphics = AssetExtension::vectorGraphics(); // SVG, AI, EPS, CDR\n$rasterGraphics = AssetExtension::rasterGraphics(); // JPG, PNG, GIF, etc.\n$spreadsheets = AssetExtension::spreadsheets(); // XLS, XLSX, ODS, CSV\n$presentations = AssetExtension::presentations(); // PPT, PPTX, ODP</code></pre>"},{"location":"basic-usage/#assetmimetype","title":"AssetMimeType","text":"<pre><code>// Available mime types (examples)\nAssetMimeType::IMAGE_JPEG;         // 'image/jpeg'\nAssetMimeType::APPLICATION_PDF;    // 'application/pdf'\nAssetMimeType::VIDEO_MP4;          // 'video/mp4'\nAssetMimeType::AUDIO_MP3;          // 'audio/mpeg'\nAssetMimeType::APPLICATION_ZIP;    // 'application/zip'\n\n// Get the file extension for a mime type\n$extension = AssetMimeType::getExtension(AssetMimeType::IMAGE_JPEG); // 'jpg'\n$extension = AssetMimeType::getMimeTypeExtension(AssetMimeType::IMAGE_JPEG); // 'jpg' (alternative method)\n\n// Check if a mime type belongs to a specific category\nif (AssetMimeType::isImage(AssetMimeType::IMAGE_JPEG)) {\n    // Do something with the image\n}\nif (AssetMimeType::isDocument(AssetMimeType::APPLICATION_PDF)) {\n    // Do something with the document\n}\nif (AssetMimeType::isVideo(AssetMimeType::VIDEO_MP4)) {\n    // Do something with the video\n}\nif (AssetMimeType::isAudio(AssetMimeType::AUDIO_MP3)) {\n    // Do something with the audio\n}\n\n// More specific category checks\nif (AssetMimeType::isVectorGraphic(AssetMimeType::IMAGE_SVG)) {\n    // Do something with the vector graphic\n}\nif (AssetMimeType::isSpreadsheet(AssetMimeType::APPLICATION_XLSX)) {\n    // Do something with the spreadsheet\n}\n\n// Get a mime type from a file extension\n$mimeType = AssetMimeType::fromExtension('jpg'); // 'image/jpeg'\n\n// Get a mime type from an AssetExtension enum\n$mimeType = AssetMimeType::fromAssetExtension(AssetExtension::JPG); // 'image/jpeg'</code></pre>"},{"location":"basic-usage/#advanced-usage","title":"Advanced Usage","text":"<p>For more advanced usage scenarios, check out the following topics:</p> <ul> <li>Custom Asset Collections</li> <li>Custom Path Generators</li> <li>Troubleshooting</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>CodeIgniter Asset Connect provides several configuration options to customize its behavior. This page explains how to configure the library to suit your needs.</p>"},{"location":"configuration/#configuration-file","title":"Configuration File","text":"<p>The configuration for Asset Connect is managed through the <code>Config\\Asset.php</code> file. If this file doesn't exist in your application's config directory, you can create it:</p> <pre><code>use Maniaba\\AssetConnect\\Config\\Asset as BaseAssetConfig;\n\nclass Asset extends BaseAssetConfig\n{\n    // Your custom configuration here\n}</code></pre>"},{"location":"configuration/#available-configuration-options","title":"Available Configuration Options","text":""},{"location":"configuration/#entity-type-definitions","title":"Entity Type Definitions","text":"<p>Required Configuration</p> <p>You must define entity types and their unique identifiers for all entities that will use Asset Connect. This is a required configuration for the library to function properly:</p> <pre><code>public array $entityKeyDefinitions = [\n    Product::class =&gt; 'product',\n    User::class =&gt; 'user',\n    BlogPost::class =&gt; 'blog_post',\n];</code></pre> <p>Each entity class is mapped to a unique string identifier. This identifier is stored in the database and is essential for Asset Connect to:</p> <ul> <li>Identify which type of entity the asset belongs to</li> <li>Associate assets with the correct entities</li> <li>Query assets by entity type</li> <li>Maintain data integrity across your application</li> </ul> <p>Example:</p> <pre><code>use App\\Entities\\Product;\nuse App\\Entities\\User;\n\npublic array $entityKeyDefinitions = [\n    Product::class =&gt; 'product',\n    User::class =&gt; 'user',\n];</code></pre> <p>The entity class must extend <code>CodeIgniter\\Entity\\Entity</code>.</p> <p>Important: Every entity that uses the <code>UseAssetConnectTrait</code> must be registered in this array. Failure to do so will prevent the library from functioning correctly.</p>"},{"location":"configuration/#collection-key-definitions","title":"Collection Key Definitions","text":"<p>Required Configuration</p> <p>You must define collection key definitions for all asset collections used in your application. These unique identifiers are required for Asset Connect to work properly:</p> <pre><code>public array $collectionKeyDefinitions = [\n    ImagesCollection::class =&gt; 'images',\n    DocumentsCollection::class =&gt; 'documents',\n    VideosCollection::class =&gt; 'videos',\n];</code></pre> <p>Each collection class is mapped to a unique string identifier that is stored in the database. This is essential for:</p> <ul> <li>Asset Collection Management: Identifying which collection an asset belongs to</li> <li>Database Integrity: Maintaining consistent data relationships</li> <li>Query Operations: Enabling the library to filter and retrieve assets by collection type</li> <li>Refactoring Safety: Allowing you to change class names without breaking existing data</li> </ul> <p>Example:</p> <pre><code>use App\\AssetCollections\\ProfilePicturesCollection;\nuse App\\AssetCollections\\ProductImagesCollection;\nuse App\\AssetCollections\\DocumentsCollection;\n\npublic array $collectionKeyDefinitions = [\n    ProfilePicturesCollection::class =&gt; 'profile_pictures',\n    ProductImagesCollection::class =&gt; 'product_images',\n    DocumentsCollection::class =&gt; 'documents',\n];</code></pre> <p>The collection class must implement the <code>AssetCollectionDefinitionInterface</code>.</p> <p>Important: Every asset collection class you create must be registered in this array. Without this registration, Asset Connect will not be able to process assets for that collection.</p>"},{"location":"configuration/#database-group","title":"Database Group","text":"<p>You can specify which database group to use for the Asset Connect models:</p> <pre><code>public ?string $DBGroup = 'default';</code></pre> <p>If set to <code>null</code> (default), the library will use the default database group configured in your application.</p>"},{"location":"configuration/#default-asset-collection","title":"Default Asset Collection","text":"<p>You can change the default collection class that will be used when no specific collection is provided:</p> <pre><code>public string $defaultCollection = CustomAssetCollection::class;</code></pre> <p>The class must implement the <code>AssetCollectionDefinitionInterface</code>.</p> <p>For detailed information about creating and customizing asset collections, see the Custom Asset Collections documentation.</p>"},{"location":"configuration/#default-path-generator","title":"Default Path Generator","text":"<p>The path generator determines how file paths are generated for stored assets:</p> <pre><code>public string $defaultPathGenerator = CustomPathGenerator::class;</code></pre> <p>The class must implement the <code>PathGeneratorInterface</code>.</p> <p>For detailed information about creating and customizing path generators, see the Custom Path Generators documentation.</p>"},{"location":"configuration/#default-url-generator","title":"Default URL Generator","text":"<p>The URL generator determines how URLs are generated for accessing assets:</p> <pre><code>public ?string $defaultUrlGenerator = CustomUrlGenerator::class;</code></pre> <p>The class must implement the <code>UrlGeneratorInterface</code>. If set to <code>null</code>, the default URL generator will be used and routes will not be registered.</p> <p>For detailed information about URL generators, see the Custom URL Generator documentation.</p>"},{"location":"configuration/#table-names","title":"Table Names","text":"<p>You can customize the name of the database table used by Asset Connect:</p> <pre><code>public array $tables = [\n    'assets' =&gt; 'custom_assets_table',\n];</code></pre> <p>This is useful if you need to rename the default table for security reasons, to prevent conflicts, or to comply with your organization's naming conventions.</p>"},{"location":"configuration/#queue-configuration","title":"Queue Configuration","text":"<p>You can specify the configuration for the queue that will be used for processing asset manipulations and garbage collection:</p> <pre><code>public array $queue = [\n    'name'       =&gt; 'asset_connect_queue',\n    'jobHandler' =&gt; [\n        'name'  =&gt; 'asset_variants_process',\n        'class' =&gt; AssetConnectJob::class,\n    ],\n];</code></pre> <p>The queue serves an important role in the file deletion process. When you delete assets from an entity using the <code>deleteAssets()</code> method, the records are immediately marked with soft delete in the database, but the actual files are not immediately removed from storage. Instead, a queue job is scheduled to clean up these files later. This approach prevents performance issues when deleting large numbers of files and ensures that file system operations don't slow down your application's response time.</p>"},{"location":"custom-asset-collections/","title":"Custom Asset Collections","text":"<p>Asset collections allow you to organize your assets into logical groups. You can create custom collections by implementing the <code>AssetCollectionDefinitionInterface</code>:</p> <p>Here's a simple example of a collection that only allows image files and limits the size to 5 MB:</p> <pre><code>class SingleImageCollection implements AssetCollectionDefinitionInterface, AssetVariantsInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition-&gt;singleFileCollection()\n            -&gt;setMaxFileSize(5 * 1024 * 1024) // 5 MB\n            -&gt;allowedExtensions(...AssetExtension::images());\n    }\n\n    public function checkAuthorization(array|Entity $entity, Asset $asset): bool\n    {\n        return true;\n    }\n\n    public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void\n    {\n        // No variants needed\n    }\n}</code></pre> <p>For more complex collections, you can customize the configuration further:</p> <pre><code>class ProfilePicturesCollection implements AssetCollectionDefinitionInterface, AssetVariantsInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        // Allow specific file extensions using the AssetExtension enum\n        $definition-&gt;allowedExtensions(\n            AssetExtension::JPG,\n            AssetExtension::PNG,\n            AssetExtension::GIF,\n            // You can also use string values\n            'webp'\n        )\n        // Alternatively, you can use the spread operator with AssetExtension::images()\n        // to allow all image extensions at once\n        // -&gt;allowedExtensions(...AssetExtension::images())\n        // Allow specific MIME types using the AssetMimeType enum\n        -&gt;allowedMimeTypes(\n            AssetMimeType::IMAGE_JPEG,\n            AssetMimeType::IMAGE_PNG,\n            AssetMimeType::IMAGE_GIF,\n            // You can also use string values\n            'image/webp'\n        )\n        // Set maximum file size (in bytes)\n        -&gt;setMaxFileSize(5 * 1024 * 1024) // 5MB\n\n        // Make this a single-file collection (only one file allowed)\n        // This is equivalent to calling onlyKeepLatest(1)\n        -&gt;singleFileCollection()\n\n        // OR set a maximum number of files to keep (deletes oldest when exceeded)\n        // -&gt;onlyKeepLatest(10) // Keep only the 10 most recent files\n\n        // Set a custom path generator for this collection\n        -&gt;setPathGenerator(new CustomPathGenerator());\n    }\n\n    public function checkAuthorization(array|Entity $entity, Asset $asset): bool\n    {\n        // Check if the user is authorized to access this asset\n        return true;\n    }\n\n    public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void\n    {\n        // Define file variants (e.g., thumbnails)\n    }\n}</code></pre>"},{"location":"custom-asset-collections/#understanding-assetcollectiondefinitioninterface","title":"Understanding AssetCollectionDefinitionInterface","text":"<p>The <code>AssetCollectionDefinitionInterface</code> requires you to implement the following method:</p>"},{"location":"custom-asset-collections/#definition","title":"definition","text":"<pre><code>public function definition(AssetCollectionSetterInterface $definition): void</code></pre> <p>This method is where you configure the collection's settings, such as allowed file types, maximum file size, and other constraints.</p>"},{"location":"custom-asset-collections/#understanding-authorizableassetcollectiondefinitioninterface","title":"Understanding AuthorizableAssetCollectionDefinitionInterface","text":"<p>The <code>AuthorizableAssetCollectionDefinitionInterface</code> extends <code>AssetCollectionDefinitionInterface</code> and adds authorization capabilities to asset collections. This interface is used when you need to control access to assets based on user permissions or other criteria.</p>"},{"location":"custom-asset-collections/#checkauthorization","title":"checkAuthorization","text":"<pre><code>public function checkAuthorization(Asset $asset): bool</code></pre> <p>This method determines whether a user is authorized to access an asset. It's called when an asset is requested through the AssetConnectController. The method should return <code>true</code> if access is allowed and <code>false</code> if access should be denied.</p> <p>Files typically stored in collections implementing this interface are user-specific, such as profile pictures or documents that should only be accessible to certain users.</p>"},{"location":"custom-asset-collections/#example-implementation","title":"Example Implementation","text":"<pre><code>class SecureDocumentsCollection implements AuthorizableAssetCollectionDefinitionInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition\n            -&gt;allowedExtensions(\n                AssetExtension::PDF,\n                AssetExtension::DOC,\n                AssetExtension::DOCX\n            )\n            -&gt;setMaxFileSize(10 * 1024 * 1024); // 10MB\n    }\n\n    public function checkAuthorization(Asset $asset): bool\n    {\n        // Get the current user\n        $user = service('auth')-&gt;user();\n\n        // Get the entity that owns the asset\n        $entity = $asset-&gt;getSubjectEntity();\n\n        // Check if the user is the owner of the entity or an admin\n        return ($user-&gt;id === $entity-&gt;user_id) || $user-&gt;isAdmin();\n    }\n}</code></pre> <p>In this example, the <code>checkAuthorization</code> method checks if the current user is either the owner of the entity that the asset belongs to or an admin. If either condition is true, access is granted; otherwise, it's denied.</p>"},{"location":"custom-asset-collections/#understanding-assetvariantsinterface","title":"Understanding AssetVariantsInterface","text":"<p>If your collection needs to support variants (like thumbnails or different sizes of images), you should also implement the <code>AssetVariantsInterface</code>:</p>"},{"location":"custom-asset-collections/#variants","title":"variants","text":"<pre><code>public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void</code></pre> <p>This method is where you define the variants that should be created for assets in this collection.</p>"},{"location":"custom-asset-collections/#available-configuration-options","title":"Available Configuration Options","text":"<p>The <code>AssetCollectionSetterInterface</code> provides several methods for configuring your collections:</p>"},{"location":"custom-asset-collections/#allowedextensions","title":"allowedExtensions","text":"<pre><code>public function allowedExtensions(string|AssetExtension ...$extensions): self</code></pre> <p>Specifies which file extensions are allowed in the collection. You can use the <code>AssetExtension</code> enum or string values.</p>"},{"location":"custom-asset-collections/#allowedmimetypes","title":"allowedMimeTypes","text":"<pre><code>public function allowedMimeTypes(string|AssetMimeType ...$mimeTypes): self</code></pre> <p>Specifies which MIME types are allowed in the collection. You can use the <code>AssetMimeType</code> enum or string values.</p>"},{"location":"custom-asset-collections/#setmaxfilesize","title":"setMaxFileSize","text":"<pre><code>public function setMaxFileSize(int $maxFileSize): self</code></pre> <p>Sets the maximum file size (in bytes) allowed for assets in the collection.</p>"},{"location":"custom-asset-collections/#singlefilecollection","title":"singleFileCollection","text":"<pre><code>public function singleFileCollection(): self</code></pre> <p>Makes the collection a single-file collection, meaning it can only contain one asset at a time. When a new asset is added, any existing assets are automatically deleted.</p>"},{"location":"custom-asset-collections/#onlykeeplatest","title":"onlyKeepLatest","text":"<pre><code>public function onlyKeepLatest(int $count): self</code></pre> <p>Sets the maximum number of assets to keep in the collection. When this limit is exceeded, the oldest assets are automatically deleted.</p>"},{"location":"custom-asset-collections/#setpathgenerator","title":"setPathGenerator","text":"<pre><code>public function setPathGenerator(PathGeneratorInterface $pathGenerator): self</code></pre> <p>Sets a custom path generator for the collection, which determines how file paths are generated for stored assets.</p>"},{"location":"custom-asset-collections/#best-practices","title":"Best Practices","text":"<p>When creating custom asset collections, consider the following best practices:</p>"},{"location":"custom-asset-collections/#validate-file-types","title":"Validate File Types","text":"<p>Always validate file types to ensure that only the expected types of files are stored in your collections. This helps prevent security issues and ensures that your application can properly handle the files.</p> <pre><code>$definition-&gt;allowedExtensions(...AssetExtension::images())\n    -&gt;allowedMimeTypes(...AssetMimeType::getImageMimeTypes());</code></pre>"},{"location":"custom-asset-collections/#limit-file-sizes","title":"Limit File Sizes","text":"<p>Set appropriate file size limits to prevent users from uploading excessively large files that could cause performance issues or storage problems.</p> <pre><code>$definition-&gt;setMaxFileSize(10 * 1024 * 1024); // 10MB</code></pre>"},{"location":"custom-asset-collections/#use-single-file-collections-when-appropriate","title":"Use Single-File Collections When Appropriate","text":"<p>If your entity should only have one file of a certain type (like a profile picture), use a single-file collection to automatically handle the replacement of old files.</p> <pre><code>$definition-&gt;singleFileCollection();</code></pre>"},{"location":"custom-asset-collections/#implement-proper-authorization","title":"Implement Proper Authorization","text":"<p>Always implement proper authorization checks in the <code>checkAuthorization</code> method to ensure that only authorized users can access assets.</p> <pre><code>public function checkAuthorization(array|Entity $entity, Asset $asset): bool\n{\n    // Check if the user is authorized to access this asset\n    $user = service('auth')-&gt;user();\n    return $user-&gt;id === $entity-&gt;user_id || $user-&gt;isAdmin();\n}</code></pre>"},{"location":"custom-asset-collections/#conclusion","title":"Conclusion","text":"<p>Custom asset collections provide a powerful way to organize and manage files in your application. By implementing the <code>AssetCollectionDefinitionInterface</code> and configuring your collections appropriately, you can ensure that your application handles files in a secure, efficient, and organized manner.</p>"},{"location":"custom-path-generators/","title":"Custom Path Generators","text":"<p>Path generators determine how file paths are generated for stored assets. This page explains how to create and customize path generators to suit your needs.</p>"},{"location":"custom-path-generators/#creating-custom-path-generators","title":"Creating Custom Path Generators","text":"<p>Path generators determine how file paths are generated for stored assets. You can create custom path generators by implementing the <code>PathGeneratorInterface</code>:</p> <pre><code>class CustomPathGenerator implements PathGeneratorInterface\n{\n    // Get the path for the given asset, relative to the root storage path.\n    // It's important to generate unique paths to prevent file overwrites.\n    public function getPath(PathGeneratorHelper $generatorHelper, AssetCollectionGetterInterface $collection): string\n    {\n        // Check if the collection is protected (non-public) or public\n        $isProtected = $collection-&gt;getVisibility() === AssetVisibility::PROTECTED;\n\n        // Set the base path based on visibility\n        $basePath = $isProtected ? WRITEPATH : realpath(ROOTPATH . 'public') . DIRECTORY_SEPARATOR;\n\n        // Generate a unique path using helper methods\n        // This creates a structure like: assets/2023-05-25/123456.789/\n        return $basePath . $generatorHelper-&gt;getPathString(\n            'assets',\n            $generatorHelper-&gt;getDateTime(),\n            $generatorHelper-&gt;getUniqueId()\n        );\n    }\n\n    // Get the path for variants (e.g., thumbnails) of the given asset.\n    // This should also generate unique paths.\n    public function getPathForVariants(PathGeneratorHelper $generatorHelper, AssetCollectionGetterInterface $collection): string\n    {\n        // Get the base path from the getPath method\n        $basePath = $this-&gt;getPath($generatorHelper, $collection);\n\n        // Add a 'variants' subdirectory\n        return $basePath . $generatorHelper-&gt;getPathString('variants');\n    }\n\n    // This method is called when a directory is created by the system.\n    // You can use it to perform additional operations on the directory,\n    // such as setting permissions, creating additional subdirectories,\n    // or logging directory creation events.\n    public function onCreatedDirectory(string $path): void\n    {\n        // Example: Set specific permissions on the created directory\n        // chmod($path, 0755);\n\n        // Example: Log directory creation\n        // log_message('info', 'Directory created: ' . $path);\n\n        // Example: Create additional subdirectories if needed\n        // mkdir($path . 'thumbnails', 0755, true);\n\n        // Example: Create an index.html file to prevent directory listing\n        // file_put_contents($path . 'index.html', '&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Directory access is forbidden.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;');\n\n        // Example: Create a .htaccess file to restrict direct access\n        // file_put_contents($path . '.htaccess', \"Options -Indexes\\nDeny from all\");\n    }\n}</code></pre>"},{"location":"custom-path-generators/#securing-asset-directories","title":"Securing Asset Directories","text":"<p>When storing assets, especially in public directories, it's important to consider security. The <code>onCreatedDirectory</code> method provides an excellent opportunity to add security measures to your asset directories. Here are two common approaches:</p>"},{"location":"custom-path-generators/#creating-indexhtml-files","title":"Creating index.html Files","text":"<p>Adding an index.html file to each directory prevents users from browsing the directory contents directly. If someone tries to access the directory in a browser, they'll see the contents of the index.html file instead of a listing of all files:</p> <pre><code>// Create an index.html file to prevent directory listing\nfile_put_contents($path . 'index.html', '&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Directory access is forbidden.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;');</code></pre> <p>This is a simple and effective approach that works on virtually all web servers.</p>"},{"location":"custom-path-generators/#creating-htaccess-files","title":"Creating .htaccess Files","text":"<p>For Apache servers, you can create a .htaccess file to have more control over directory access:</p> <pre><code>// Create a .htaccess file to restrict direct access\nfile_put_contents($path . '.htaccess', \"Options -Indexes\\nDeny from all\");</code></pre> <p>This .htaccess file does two things: 1. <code>Options -Indexes</code> - Prevents directory listing 2. <code>Deny from all</code> - Blocks direct access to files in this directory</p> <p>Note that when using .htaccess to deny all access, you'll need to create specific rules in your application's main .htaccess file to allow access to the files through your application's controllers.</p>"},{"location":"custom-path-generators/#understanding-pathgeneratorhelper","title":"Understanding PathGeneratorHelper","text":"<p>The <code>PathGeneratorHelper</code> class provides several useful methods for generating unique paths:</p> <ol> <li> <p><code>getUniqueId(bool $moreEntropy = false)</code>: Generates a unique ID, with an option for more entropy.    <pre><code>// Basic unique ID\n$uniqueId = $generatorHelper-&gt;getUniqueId(); // e.g., \"1620000000_60a1b2c3\"\n\n// More secure unique ID with higher entropy\n$secureId = $generatorHelper-&gt;getUniqueId(true); // SHA-256 hash</code></pre></p> </li> <li> <p><code>getDateTime()</code>: Generates a date-time string formatted as a folder name.    <pre><code>$dateTimeFolder = $generatorHelper-&gt;getDateTime(); // e.g., \"2023-05-25/123456.789/\"</code></pre></p> </li> <li> <p><code>getTime()</code>: Gets the current time formatted as a string.    <pre><code>$timeString = $generatorHelper-&gt;getTime(); // e.g., \"123456.789\"</code></pre></p> </li> <li> <p><code>getPathString(string ...$segments)</code>: Joins path segments with the system's directory separator.    <pre><code>$path = $generatorHelper-&gt;getPathString('folder1', 'folder2', 'folder3'); // \"folder1/folder2/folder3/\"</code></pre></p> </li> </ol>"},{"location":"custom-path-generators/#understanding-assetcollectiongetterinterface","title":"Understanding AssetCollectionGetterInterface","text":"<p>The <code>AssetCollectionGetterInterface</code> is passed to the path generator methods and provides information about the asset collection:</p> <ol> <li> <p><code>getVisibility()</code>: Returns the visibility of the collection (PUBLIC or PROTECTED).    <pre><code>$visibility = $collection-&gt;getVisibility(); // AssetVisibility::PUBLIC or AssetVisibility::PROTECTED</code></pre></p> </li> <li> <p><code>getMaximumNumberOfItemsInCollection()</code>: Returns the maximum number of items allowed in the collection.</p> </li> <li><code>getMaxFileSize()</code>: Returns the maximum file size allowed in the collection.</li> <li><code>isSingleFileCollection()</code>: Returns whether the collection is limited to a single file.</li> <li><code>getAllowedMimeTypes()</code>: Returns an array of allowed MIME types.</li> <li><code>getAllowedExtensions()</code>: Returns an array of allowed file extensions.</li> </ol> <p>These methods can be useful when generating paths, especially <code>getVisibility()</code> which helps determine whether to store files in a public or protected location.</p>"},{"location":"custom-path-generators/#importance-of-unique-paths","title":"Importance of Unique Paths","text":"<p>When implementing custom path generators, it's crucial to ensure that each asset gets a unique path. This prevents files from overwriting each other, especially in high-traffic applications where multiple files might be uploaded simultaneously.</p> <p>The <code>PathGeneratorHelper</code> class provides methods like <code>getUniqueId()</code> and <code>getDateTime()</code> specifically to help generate unique paths. By combining these with other identifiers (like collection names, entity IDs, etc.), you can create a robust path generation strategy that minimizes the risk of collisions.</p>"},{"location":"custom-pending-storage/","title":"Custom Pending Storage","text":"<p>This guide explains how to create and configure custom storage implementations for pending assets. By default, AssetConnect uses filesystem storage (<code>DefaultPendingStorage</code>), but you can implement your own storage backend for services like Amazon S3, Redis, or any other storage solution.</p>"},{"location":"custom-pending-storage/#overview","title":"Overview","text":"<p>Custom pending storage allows you to:</p> <ul> <li>Store pending assets in cloud storage (S3, Azure Blob, Google Cloud Storage)</li> <li>Use in-memory storage for testing or caching (Redis, Memcached)</li> <li>Implement custom TTL and cleanup logic</li> <li>Add custom security token providers</li> <li>Integrate with your existing storage infrastructure</li> </ul>"},{"location":"custom-pending-storage/#implementing-pendingstorageinterface","title":"Implementing PendingStorageInterface","text":"<p>To create a custom pending storage, implement the <code>PendingStorageInterface</code>:</p> <pre><code>use Maniaba\\AssetConnect\\Pending\\Interfaces\\PendingStorageInterface;\nuse Maniaba\\AssetConnect\\Pending\\PendingAsset;\nuse Maniaba\\AssetConnect\\Pending\\Interfaces\\PendingSecurityTokenInterface;\n\nclass MyCustomPendingStorage implements PendingStorageInterface\n{\n    public function generatePendingId(): string\n    {\n        // Generate unique ID for pending asset\n    }\n\n    public function fetchById(string $id): ?PendingAsset\n    {\n        // Retrieve pending asset by ID\n    }\n\n    public function store(PendingAsset $asset, ?string $id = null): void\n    {\n        // Store pending asset\n    }\n\n    public function deleteById(string $id): bool\n    {\n        // Delete pending asset by ID\n    }\n\n    public function getDefaultTTLSeconds(): int\n    {\n        // Return default TTL in seconds\n    }\n\n    public function cleanExpiredPendingAssets(): void\n    {\n        // Remove all expired pending assets\n    }\n\n    public function pendingSecurityToken(): ?PendingSecurityTokenInterface\n    {\n        // Return security token provider (optional)\n    }\n}</code></pre>"},{"location":"custom-pending-storage/#required-methods","title":"Required Methods","text":""},{"location":"custom-pending-storage/#generatependingid","title":"generatePendingId()","text":"<p>Generates a unique identifier for a new pending asset.</p> <pre><code>public function generatePendingId(): string</code></pre> <p>Returns: Unique string identifier</p> <p>Example: <pre><code>public function generatePendingId(): string\n{\n    // Simple UUID\n    return bin2hex(random_bytes(16));\n\n    // Or with prefix\n    return uniqid('pending_', true);\n\n    // Or using UUID library\n    return Uuid::uuid4()-&gt;toString();\n}</code></pre></p>"},{"location":"custom-pending-storage/#fetchbyid","title":"fetchById()","text":"<p>Retrieves a pending asset by its ID.</p> <pre><code>public function fetchById(string $id): ?PendingAsset</code></pre> <p>Parameters: - <code>$id</code> - Unique identifier of the pending asset</p> <p>Returns: <code>PendingAsset</code> object or <code>null</code> if not found</p> <p>Example: <pre><code>public function fetchById(string $id): ?PendingAsset\n{\n    $data = $this-&gt;storageClient-&gt;get($id);\n\n    if (!$data) {\n        return null;\n    }\n\n    // Reconstruct PendingAsset from stored data\n    return PendingAsset::createFromFile($data['file_path'], $data['metadata']);\n}</code></pre></p>"},{"location":"custom-pending-storage/#store","title":"store()","text":"<p>Stores a pending asset. Should handle both new creation and metadata updates.</p> <pre><code>public function store(PendingAsset $asset, ?string $id = null): void</code></pre> <p>Parameters: - <code>$asset</code> - The pending asset to store - <code>$id</code> - Optional ID (if updating existing asset)</p> <p>Example: <pre><code>public function store(PendingAsset $asset, ?string $id = null): void\n{\n    $id ??= $this-&gt;generatePendingId();\n    $asset-&gt;setId($id);\n\n    $data = [\n        'id' =&gt; $id,\n        'file' =&gt; $asset-&gt;file-&gt;getRealPath(),\n        'metadata' =&gt; json_encode($asset),\n        'created_at' =&gt; time(),\n        'ttl' =&gt; $asset-&gt;ttl\n    ];\n\n    $this-&gt;storageClient-&gt;put($id, $data);\n}</code></pre></p>"},{"location":"custom-pending-storage/#deletebyid","title":"deleteById()","text":"<p>Deletes a pending asset by its ID.</p> <pre><code>public function deleteById(string $id): bool</code></pre> <p>Parameters: - <code>$id</code> - Unique identifier of the pending asset to delete</p> <p>Returns: <code>true</code> if deleted successfully, <code>false</code> otherwise</p> <p>Example: <pre><code>public function deleteById(string $id): bool\n{\n    return $this-&gt;storageClient-&gt;delete($id);\n}</code></pre></p>"},{"location":"custom-pending-storage/#getdefaultttlseconds","title":"getDefaultTTLSeconds()","text":"<p>Returns the default Time To Live for pending assets in seconds.</p> <pre><code>public function getDefaultTTLSeconds(): int</code></pre> <p>Returns: TTL in seconds</p> <p>Example: <pre><code>public function getDefaultTTLSeconds(): int\n{\n    // 1 hour\n    return 3600;\n\n    // 24 hours (default)\n    return 86400;\n\n    // 7 days\n    return 604800;\n}</code></pre></p>"},{"location":"custom-pending-storage/#cleanexpiredpendingassets","title":"cleanExpiredPendingAssets()","text":"<p>Removes all expired pending assets.</p> <pre><code>public function cleanExpiredPendingAssets(): void</code></pre> <p>Example: <pre><code>public function cleanExpiredPendingAssets(): void\n{\n    $allAssets = $this-&gt;storageClient-&gt;getAll();\n    $now = time();\n\n    foreach ($allAssets as $id =&gt; $asset) {\n        $expiresAt = $asset['created_at'] + $asset['ttl'];\n\n        if ($expiresAt &lt; $now) {\n            $this-&gt;deleteById($id);\n        }\n    }\n}</code></pre></p>"},{"location":"custom-pending-storage/#pendingsecuritytoken","title":"pendingSecurityToken()","text":"<p>Returns a security token provider for pending operations (optional).</p> <pre><code>public function pendingSecurityToken(): ?PendingSecurityTokenInterface</code></pre> <p>Returns: Security token provider or <code>null</code></p> <p>Example: <pre><code>public function pendingSecurityToken(): ?PendingSecurityTokenInterface\n{\n    return new MyCustomSecurityToken();\n}</code></pre></p>"},{"location":"custom-pending-storage/#storage-implementation-examples","title":"Storage Implementation Examples","text":"<p>You can implement custom storage for various backends based on your needs:</p> <ul> <li>Cloud Storage: Amazon S3, Azure Blob Storage, Google Cloud Storage</li> <li>In-Memory Storage: Redis, Memcached (useful for fast temporary storage with automatic TTL handling)</li> <li>Database Storage: MySQL, PostgreSQL (store metadata and file paths or binary data)</li> <li>Distributed Storage: Ceph, MinIO, or other object storage solutions</li> </ul> <p>Each implementation should follow the <code>PendingStorageInterface</code> contract and handle file storage, metadata management, and expiration logic according to your specific infrastructure requirements.</p>"},{"location":"custom-pending-storage/#configuring-custom-storage","title":"Configuring Custom Storage","text":"<p>After implementing your custom storage, configure it in <code>app/Config/Asset.php</code>:</p> <pre><code>namespace Config;\n\nuse Maniaba\\AssetConnect\\Config\\Asset as BaseConfig;\nuse App\\Storage\\S3PendingStorage;\n\nclass Asset extends BaseConfig\n{\n    public string $pendingStorage = S3PendingStorage::class;\n}</code></pre>"},{"location":"custom-pending-storage/#using-custom-storage","title":"Using Custom Storage","text":"<p>Once configured, your custom storage will be used automatically:</p> <pre><code>// Uses your custom storage automatically\n$pending = PendingAsset::createFromFile('/path/to/file.jpg');\n$pending-&gt;store();\n\n// Also works with Pending Asset Manager\n$manager = PendingAssetManager::make();\n$pending = $manager-&gt;fetchById($id);</code></pre>"},{"location":"custom-pending-storage/#using-custom-storage-per-request","title":"Using Custom Storage Per Request","text":"<p>You can also use custom storage on a per-request basis:</p> <pre><code>use App\\Storage\\S3PendingStorage;\n\n$customStorage = new S3PendingStorage();\n\n// With PendingAsset\n$pending = PendingAsset::createFromFile('/path/to/file.jpg');\n$pending-&gt;store($customStorage);\n\n// With Pending Asset Manager\n$manager = PendingAssetManager::make($customStorage);\n\n// With addAssetFromPending\n$user-&gt;addAssetFromPending($pendingId, $customStorage)\n    -&gt;toAssetCollection(Photos::class);</code></pre>"},{"location":"custom-pending-storage/#best-practices","title":"Best Practices","text":""},{"location":"custom-pending-storage/#1-handle-expiration-properly","title":"1. Handle Expiration Properly","text":"<pre><code>public function fetchById(string $id): ?PendingAsset\n{\n    // Always check TTL before returning\n    if ($this-&gt;isExpired($id)) {\n        $this-&gt;deleteById($id);\n        return null;\n    }\n\n    return $this-&gt;loadAsset($id);\n}</code></pre>"},{"location":"custom-pending-storage/#2-use-appropriate-ttl","title":"2. Use Appropriate TTL","text":"<pre><code>public function getDefaultTTLSeconds(): int\n{\n    // Shorter TTL for memory storage\n    if ($this-&gt;isMemoryStorage()) {\n        return 3600; // 1 hour\n    }\n\n    // Longer TTL for persistent storage\n    return 86400; // 24 hours\n}</code></pre>"},{"location":"custom-pending-storage/#3-implement-proper-error-handling","title":"3. Implement Proper Error Handling","text":"<pre><code>public function store(PendingAsset $asset, ?string $id = null): void\n{\n    try {\n        $this-&gt;doStore($asset, $id);\n    } catch (\\Exception $e) {\n        log_message('error', 'Failed to store pending asset: ' . $e-&gt;getMessage());\n        throw PendingAssetException::forUnableToStorePendingAsset(\n            $id ?? 'unknown',\n            $e-&gt;getMessage()\n        );\n    }\n}</code></pre>"},{"location":"custom-pending-storage/#4-cleanup-resources","title":"4. Cleanup Resources","text":"<pre><code>public function __destruct()\n{\n    // Close connections\n    if ($this-&gt;connection) {\n        $this-&gt;connection-&gt;close();\n    }\n}</code></pre>"},{"location":"custom-pending-storage/#5-add-logging","title":"5. Add Logging","text":"<pre><code>public function deleteById(string $id): bool\n{\n    $success = $this-&gt;performDelete($id);\n\n    if ($success) {\n        log_message('info', \"Deleted pending asset: {$id}\");\n    } else {\n        log_message('warning', \"Failed to delete pending asset: {$id}\");\n    }\n\n    return $success;\n}</code></pre>"},{"location":"custom-pending-storage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"custom-pending-storage/#storage-connection-issues","title":"Storage Connection Issues","text":"<pre><code>public function __construct()\n{\n    try {\n        $this-&gt;initializeStorage();\n    } catch (\\Exception $e) {\n        log_message('critical', 'Failed to initialize pending storage: ' . $e-&gt;getMessage());\n        throw new \\RuntimeException('Pending storage initialization failed');\n    }\n}</code></pre>"},{"location":"custom-pending-storage/#large-file-handling","title":"Large File Handling","text":"<pre><code>public function store(PendingAsset $asset, ?string $id = null): void\n{\n    $fileSize = $asset-&gt;size;\n    $maxSize = 100 * 1024 * 1024; // 100MB\n\n    if ($fileSize &gt; $maxSize) {\n        throw new PendingAssetException(\"File too large for pending storage: {$fileSize} bytes\");\n    }\n\n    // Use streaming for large files\n    $this-&gt;streamStore($asset, $id);\n}</code></pre>"},{"location":"custom-pending-storage/#memory-management","title":"Memory Management","text":"<pre><code>public function fetchById(string $id): ?PendingAsset\n{\n    // Don't load entire file into memory\n    $metadata = $this-&gt;fetchMetadata($id);\n\n    if (!$metadata) {\n        return null;\n    }\n\n    // Stream file to temp location\n    $tempFile = $this-&gt;streamToTemp($id);\n\n    return PendingAsset::createFromFile($tempFile, $metadata);\n}</code></pre>"},{"location":"custom-pending-storage/#see-also","title":"See Also","text":"<ul> <li>Pending Assets - Overview of pending assets functionality</li> <li>Pending Asset Manager - Manager class documentation</li> <li>DefaultPendingStorage - Default filesystem implementation</li> </ul>"},{"location":"custom-url-generator/","title":"Custom URL Generator","text":"<p>The URL Generator is a core component of CodeIgniter Asset Connect that handles the generation of URLs for accessing assets. While the library provides a default implementation (<code>DefaultUrlGenerator</code>), you can create your own custom URL generator to customize how asset URLs are generated.</p>"},{"location":"custom-url-generator/#why-create-a-custom-url-generator","title":"Why Create a Custom URL Generator?","text":"<p>There are several reasons why you might want to create a custom URL generator:</p> <ol> <li>Custom URL Structure: You may want to use a different URL structure than the default one, such as including additional segments or using different naming conventions.</li> <li>Custom Security: You might want to implement additional security measures in your URLs, such as signed URLs or custom token formats.</li> <li>SEO Optimization: Custom URL structures can be more SEO-friendly, including relevant keywords or more readable paths.</li> <li>Legacy System Compatibility: If you're integrating with a legacy system, you might need to generate URLs that match its expected format.</li> </ol>"},{"location":"custom-url-generator/#implementing-a-custom-url-generator","title":"Implementing a Custom URL Generator","text":"<p>To create a custom URL generator, you need to implement the <code>UrlGeneratorInterface</code>. This interface requires two methods:</p> <ol> <li><code>routes(RouteCollection &amp;$routes): void</code> - Defines the routes needed for accessing assets.</li> <li><code>params(int $assetId, ?string $variantName, string $filename, ?string $token = null): array</code> - Generates the parameters for the routes based on asset information.</li> </ol> <p>Here's a basic example of a custom URL generator:</p> <pre><code>&lt;?php\n\nnamespace App\\UrlGenerators;\n\nuse CodeIgniter\\Router\\RouteCollection;\nuse Maniaba\\AssetConnect\\Controllers\\AssetConnectController;\nuse Maniaba\\AssetConnect\\UrlGenerator\\Interfaces\\UrlGeneratorInterface;\n\nclass CustomUrlGenerator implements UrlGeneratorInterface\n{\n    public static function routes(RouteCollection &amp;$routes): void\n    {\n        $routes-&gt;group('files', static function (RouteCollection $routes) {\n            // Route for regular assets\n            $routes-&gt;get('view/(:num)/(:segment)', [AssetConnectController::class, 'show/$1/$3'], [\n                'priority' =&gt; 100,\n                'as'       =&gt; 'custom-asset.show',\n            ]);\n\n            // Route for asset variants\n            $routes-&gt;get('view/(:num)/variant/(:segment)/(:segment)', [AssetConnectController::class, 'show/$1/$2'], [\n                'priority' =&gt; 100,\n                'as'       =&gt; 'custom-asset.show_variant',\n            ]);\n\n            // Route for temporary assets\n            $routes-&gt;get('temp/(:segment)/(:segment)', [AssetConnectController::class, 'temporary/$1'], [\n                'priority' =&gt; 100,\n                'as'       =&gt; 'custom-asset.temporary',\n            ]);\n\n            // Route for temporary asset variants\n            $routes-&gt;get('temp/(:segment)/variant/(:segment)/(:segment)', [AssetConnectController::class, 'temporary/$1'], [\n                'priority' =&gt; 100,\n                'as'       =&gt; 'custom-asset.temporary_variant',\n            ]);\n        });\n    }\n\n    public static function params(int $assetId, ?string $variantName, string $filename, ?string $token = null): array\n    {\n        return [\n            'custom-asset.show'              =&gt; [$assetId, $filename],\n            'custom-asset.show_variant'      =&gt; [$assetId, $variantName, $filename],\n            'custom-asset.temporary'         =&gt; [$token, $filename],\n            'custom-asset.temporary_variant' =&gt; [$token, $variantName, $filename],\n        ];\n    }\n}</code></pre> <p>This custom URL generator creates URLs with the following structure:</p> <ul> <li>Regular assets: <code>/files/view/{assetId}/{filename}</code></li> <li>Asset variants: <code>/files/view/{assetId}/variant/{variantName}/{filename}</code></li> <li>Temporary assets: <code>/files/temp/{token}/{filename}</code></li> <li>Temporary asset variants: <code>/files/temp/{token}/variant/{variantName}/{filename}</code></li> </ul>"},{"location":"custom-url-generator/#more-advanced-examples","title":"More Advanced Examples","text":""},{"location":"custom-url-generator/#seo-friendly-urls","title":"SEO-Friendly URLs","text":"<p>If you want more SEO-friendly URLs, you might create a URL generator like this:</p> <pre><code>&lt;?php\n\nnamespace App\\UrlGenerators;\n\nuse CodeIgniter\\Router\\RouteCollection;\nuse Maniaba\\AssetConnect\\Controllers\\AssetConnectController;\nuse Maniaba\\AssetConnect\\UrlGenerator\\Interfaces\\UrlGeneratorInterface;\n\nclass SeoUrlGenerator implements UrlGeneratorInterface\n{\n    public static function routes(RouteCollection &amp;$routes): void\n    {\n        $routes-&gt;group('media', static function (RouteCollection $routes) {\n            // Route for regular assets with SEO-friendly structure\n            $routes-&gt;get('(:num)/(:segment)', [AssetConnectController::class, 'show/$1/$3'], [\n                'priority' =&gt; 100,\n                'as'       =&gt; 'media.show',\n            ]);\n\n            // Route for asset variants with SEO-friendly structure\n            $routes-&gt;get('(:num)/(:segment)/(:segment)', [AssetConnectController::class, 'show/$1/$2'], [\n                'priority' =&gt; 100,\n                'as'       =&gt; 'media.show_variant',\n            ]);\n\n            // Routes for temporary assets\n            $routes-&gt;get('shared/(:segment)/(:segment)', [AssetConnectController::class, 'temporary/$1'], [\n                'priority' =&gt; 100,\n                'as'       =&gt; 'media.temporary',\n            ]);\n\n            $routes-&gt;get('shared/(:segment)/(:segment)/(:segment)', [AssetConnectController::class, 'temporary/$1'], [\n                'priority' =&gt; 100,\n                'as'       =&gt; 'media.temporary_variant',\n            ]);\n        });\n    }\n\n    public static function params(int $assetId, ?string $variantName, string $filename, ?string $token = null): array\n    {\n        return [\n            'media.show' =&gt; [$assetId, $filename],\n            'media.show_variant' =&gt; [$assetId, $variantName, $filename],\n            'media.temporary' =&gt; [$token, $filename],\n            'media.temporary_variant' =&gt; [$token, $variantName, $filename],\n        ];\n    }\n}</code></pre> <p>This custom URL generator creates URLs with the following structure:</p> <ul> <li>Regular assets: <code>/media/{assetId}/{filename}</code></li> <li>Asset variants: <code>/media/{assetId}/{variantName}/{filename}</code></li> <li>Temporary assets: <code>/media/shared/{token}/{filename}</code></li> <li>Temporary asset variants: <code>/media/shared/{token}/{variantName}/{filename}</code></li> </ul>"},{"location":"custom-url-generator/#configuring-your-application-to-use-a-custom-url-generator","title":"Configuring Your Application to Use a Custom URL Generator","text":"<p>Once you've created your custom URL generator, you need to configure your application to use it. This is done in your <code>Config\\Asset.php</code> file:</p> <pre><code>&lt;?php\n\nnamespace Config;\n\nuse App\\UrlGenerators\\CustomUrlGenerator;\nuse Maniaba\\AssetConnect\\Config\\Asset as BaseAsset;\n\nclass Asset extends BaseAsset\n{\n    // Set your custom URL generator\n    public string $urlGenerator = CustomUrlGenerator::class;\n\n    // Other configuration options...\n}</code></pre>"},{"location":"custom-url-generator/#how-url-generation-works","title":"How URL Generation Works","text":"<p>When you call methods like <code>getUrl()</code> or <code>getTemporaryUrl()</code> on an Asset object, the following process occurs:</p> <ol> <li>The Asset object uses the UrlGeneratorTrait to call the appropriate method on the URL generator.</li> <li>The URL generator generates the parameters for the route based on the asset information.</li> <li>The parameters are used to generate the URL using CodeIgniter's <code>site_url()</code> function or directly returned if using a custom URL format.</li> <li>The URL is returned to the caller.</li> </ol>"},{"location":"custom-url-generator/#best-practices","title":"Best Practices","text":"<p>When creating a custom URL generator, consider the following best practices:</p> <ol> <li>Security: Ensure that your URL structure doesn't expose sensitive information or allow unauthorized access to assets.</li> <li>Compatibility: Make sure your custom URLs work with all asset types and variants.</li> <li>Performance: Keep URL generation efficient, especially if you're generating URLs for many assets at once.</li> <li>Readability: Create URLs that are human-readable and meaningful when possible.</li> <li>Consistency: Maintain a consistent URL structure across your application.</li> </ol>"},{"location":"custom-url-generator/#conclusion","title":"Conclusion","text":"<p>Creating a custom URL generator allows you to customize how asset URLs are generated in your application. By implementing the <code>UrlGeneratorInterface</code>, you can create URLs that match your specific requirements, whether for SEO or custom security measures.</p> <p>Remember that changing the URL structure will affect all existing links to assets in your application, so it's best to implement a custom URL generator early in your development process or provide a migration path for existing links.</p>"},{"location":"events/","title":"Events","text":"<p>CodeIgniter Asset Connect fires several events that you can listen for in your application. These events allow you to perform custom actions when assets are created, updated, deleted, or when variants are created.</p>"},{"location":"events/#available-events","title":"Available Events","text":"<p>Asset Connect fires the following events:</p> Event Name Description Event Object <code>asset.created</code> Fired when an asset is created <code>AssetCreated</code> <code>asset.updated</code> Fired when an asset is updated <code>AssetUpdated</code> <code>asset.deleted</code> Fired when an asset is deleted <code>AssetDeleted</code> <code>variant.created</code> Fired when a variant is created <code>VariantCreated</code>"},{"location":"events/#listening-for-events","title":"Listening for Events","text":"<p>You can listen for these events in your application's <code>app/Config/Events.php</code> file:</p> <pre><code>// In app/Config/Events.php\n\nuse CodeIgniter\\Events\\Events;\nuse Maniaba\\AssetConnect\\Events\\AssetCreated;\nuse Maniaba\\AssetConnect\\Events\\AssetUpdated;\nuse Maniaba\\AssetConnect\\Events\\AssetDeleted;\nuse Maniaba\\AssetConnect\\Events\\VariantCreated;\n\n// Listen for asset.created event\nEvents::on('asset.created', function (AssetCreated $event) {\n    $asset = $event-&gt;getAsset();\n\n    // Do something with the asset\n    log_message('info', 'Asset created: ' . $asset-&gt;id);\n});\n\n// Listen for asset.updated event\nEvents::on('asset.updated', function (AssetUpdated $event) {\n    $asset = $event-&gt;getAsset();\n\n    // Do something with the updated asset\n    log_message('info', 'Asset updated: ' . $asset-&gt;id);\n});\n\n// Listen for asset.deleted event\nEvents::on('asset.deleted', function (AssetDeleted $event) {\n    $asset = $event-&gt;getAsset();\n\n    // Do something with the asset\n    log_message('info', 'Asset deleted: ' . $asset-&gt;id);\n});\n\n// Listen for variant.created event\nEvents::on('variant.created', function (VariantCreated $event) {\n    $asset = $event-&gt;getAsset();\n    $variant = $event-&gt;getVariant();\n    $variantName = $variant-&gt;name;\n\n    // Do something with the asset and variant name\n    log_message('info', 'Variant created: ' . $variantName . ' for asset ' . $asset-&gt;id);\n});</code></pre>"},{"location":"events/#event-objects","title":"Event Objects","text":"<p>Each event provides an event object that contains relevant information about the event:</p>"},{"location":"events/#assetcreated","title":"AssetCreated","text":"<p>The <code>AssetCreated</code> event object provides access to the newly created asset:</p> <pre><code>Events::on('asset.created', function (AssetCreated $event) {\n    $asset = $event-&gt;getAsset();\n\n    // Access asset properties\n    $assetId = $asset-&gt;id;\n    $fileName = $asset-&gt;file_name;\n    $mimeType = $asset-&gt;mime_type;\n    $size = $asset-&gt;size;\n\n    // Access custom properties\n    $customProperties = $asset-&gt;getCustomProperties();\n\n    // Perform custom actions\n    // For example, send a notification, update a database record, etc.\n});</code></pre>"},{"location":"events/#assetupdated","title":"AssetUpdated","text":"<p>The <code>AssetUpdated</code> event object provides access to the updated asset:</p> <pre><code>Events::on('asset.updated', function (AssetUpdated $event) {\n    $asset = $event-&gt;getAsset();\n\n    // Access updated asset properties\n    // Perform custom actions based on the updated asset\n});</code></pre>"},{"location":"events/#assetdeleted","title":"AssetDeleted","text":"<p>The <code>AssetDeleted</code> event object provides access to the deleted asset:</p> <pre><code>Events::on('asset.deleted', function (AssetDeleted $event) {\n    $asset = $event-&gt;getAsset();\n\n    // Perform custom actions based on the deleted asset\n    // For example, clean up related records, update cache, etc.\n});</code></pre>"},{"location":"events/#variantcreated","title":"VariantCreated","text":"<p>The <code>VariantCreated</code> event object provides access to the asset and the variant that was created:</p> <pre><code>Events::on('variant.created', function (VariantCreated $event) {\n    $asset = $event-&gt;getAsset();\n    $variant = $event-&gt;getVariant();\n    $variantName = $variant-&gt;name;\n\n    // Access asset properties\n    $assetId = $asset-&gt;id;\n\n    // Perform custom actions based on the created variant\n    // For example, update metadata, generate additional variants, etc.\n});</code></pre>"},{"location":"events/#use-cases","title":"Use Cases","text":"<p>Here are some common use cases for using Asset Connect events:</p>"},{"location":"events/#logging-asset-activities","title":"Logging Asset Activities","text":"<pre><code>// Log all asset activities\nEvents::on('asset.created', function (AssetCreated $event) {\n    $asset = $event-&gt;getAsset();\n    log_message('info', 'Asset created: ' . $asset-&gt;id . ' (' . $asset-&gt;file_name . ')');\n});\n\nEvents::on('asset.updated', function (AssetUpdated $event) {\n    $asset = $event-&gt;getAsset();\n    log_message('info', 'Asset updated: ' . $asset-&gt;id . ' (' . $asset-&gt;file_name . ')');\n});\n\nEvents::on('asset.deleted', function (AssetDeleted $event) {\n    $asset = $event-&gt;getAsset();\n    log_message('info', 'Asset deleted: ' . $asset-&gt;id);\n});\n\nEvents::on('variant.created', function (VariantCreated $event) {\n    $asset = $event-&gt;getAsset();\n    $variant = $event-&gt;getVariant();\n    $variantName = $variant-&gt;name;\n    log_message('info', 'Variant created: ' . $variantName . ' for asset ' . $asset-&gt;id);\n});</code></pre>"},{"location":"events/#sending-notifications","title":"Sending Notifications","text":"<pre><code>// Send a notification when an asset is created\nEvents::on('asset.created', function (AssetCreated $event) {\n    $asset = $event-&gt;getAsset();\n\n    // Get the entity that owns the asset\n    $entity = $asset-&gt;getSubjectEntity();\n\n    // Send a notification to the entity owner\n    $emailService = service('email');\n    $emailService-&gt;setTo($entity-&gt;email);\n    $emailService-&gt;setSubject('New Asset Added');\n    $emailService-&gt;setMessage('A new asset has been added to your account: ' . $asset-&gt;name);\n    $emailService-&gt;send();\n});</code></pre>"},{"location":"events/#generating-additional-variants","title":"Generating Additional Variants","text":"<pre><code>// Generate additional variants when a variant is created\nEvents::on('variant.created', function (VariantCreated $event) {\n    $asset = $event-&gt;getAsset();\n    $variant = $event-&gt;getVariant();\n    $variantName = $variant-&gt;name;\n\n    // Only process certain variants\n    if ($variantName === 'thumbnail' &amp;&amp; $asset-&gt;isImage()) {\n        // Generate additional variants based on the thumbnail\n        $imageService = service('image');\n        $thumbnailPath = $asset-&gt;getVariantPath('thumbnail');\n\n        // Generate a smaller version for mobile\n        $imageService-&gt;withFile($thumbnailPath)\n            -&gt;resize(100, 100, true)\n            -&gt;save($asset-&gt;getPathDirname() . 'mobile_' . $asset-&gt;file_name);\n\n        // Add the new variant to the asset\n        $asset-&gt;addVariant('mobile', 'mobile_' . $asset-&gt;file_name);\n        $asset-&gt;save();\n    }\n});</code></pre>"},{"location":"events/#conclusion","title":"Conclusion","text":"<p>Events provide a powerful way to extend the functionality of Asset Connect without modifying its core code. By listening for events, you can implement custom behaviors such as logging, notifications, additional processing, and integration with other systems.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page provides practical examples of how to use CodeIgniter Asset Connect in your application.</p>"},{"location":"examples/#filtering-assets","title":"Filtering Assets","text":"<p>You can filter assets using the <code>filterAssets</code> method on your model:</p> <pre><code>// Filter assets by size range\n$user = model(User::class, false)\n    -&gt;filterAssets(fn(AssetModel $model) =&gt; $model-&gt;filterBySizeRange(1, 10000))\n    -&gt;first();</code></pre>"},{"location":"examples/#available-filters","title":"Available Filters","text":"<p>The AssetModel provides various filtering methods that can be categorized into different groups. These filters can be chained together for more complex queries.</p>"},{"location":"examples/#basic-metadata-filters","title":"Basic Metadata Filters","text":"<p>These filters allow you to filter assets based on their basic metadata:</p> <pre><code>// Find assets with a specific name\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByName('profile-picture');\n});\n\n// Find assets with a specific file name\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByFileName('profile.jpg');\n});\n\n// Find assets with a specific MIME type\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByMimeType('image/jpeg');\n});\n\n// Find assets with a specific size (with comparison operator)\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterBySize(1024, '&gt;='); // Files &gt;= 1KB\n});\n\n// Find assets with a specific path\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByPath('/uploads/images/');\n});\n\n// Find assets with a specific order\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByOrder(1);\n});</code></pre>"},{"location":"examples/#custom-property-filters","title":"Custom Property Filters","text":"<p>These filters allow you to filter assets based on their custom properties:</p> <pre><code>// Find assets with a specific custom property value\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByProperty('title', 'Profile Picture');\n});\n\n// Find assets that have a specific property (regardless of value)\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByPropertyExists('title');\n});\n\n// Find assets where an array property contains a specific value\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByPropertyContains('tags', 'profile');\n});</code></pre>"},{"location":"examples/#date-filters","title":"Date Filters","text":"<p>These filters allow you to filter assets based on dates:</p> <pre><code>// Find assets created after a specific date\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByCreatedAt('2023-01-01', '&gt;=');\n});\n\n// Find assets updated before a specific date\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByUpdatedAt('2023-12-31', '&lt;=');\n});\n\n// Find assets created within a date range\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByDateRange('2023-01-01', '2023-12-31', 'created_at');\n});</code></pre>"},{"location":"examples/#pattern-matching-filters","title":"Pattern Matching Filters","text":"<p>These filters allow you to filter assets using pattern matching:</p> <pre><code>// Find assets with names matching a pattern\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByNameLike('profile%'); // Names starting with \"profile\"\n});\n\n// Find assets with file names matching a pattern\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByFileNameLike('%.jpg'); // File names ending with \".jpg\"\n});</code></pre>"},{"location":"examples/#range-filters","title":"Range Filters","text":"<p>These filters allow you to filter assets within specific ranges:</p> <pre><code>// Find assets within a size range\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterBySizeRange(1024, 1024 * 1024); // Between 1KB and 1MB\n});</code></pre>"},{"location":"examples/#collection-and-entity-filters","title":"Collection and Entity Filters","text":"<p>These filters allow you to filter assets by collection or entity type:</p> <pre><code>// Find assets in a specific collection\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;whereCollection(ImagesCollection::class);\n});\n\n// Find assets associated with a specific entity type\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;whereEntityType(User::class);\n});</code></pre>"},{"location":"examples/#chaining-filters","title":"Chaining Filters","text":"<p>One of the most powerful features of the filtering system is the ability to chain multiple filters together to create complex queries. Here are some examples:</p> <pre><code>// Find large JPEG images uploaded recently\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByMimeType('image/jpeg')\n          -&gt;filterBySizeRange(1000000, PHP_INT_MAX) // Larger than 1MB\n          -&gt;filterByCreatedAt(date('Y-m-d', strtotime('-7 days')), '&gt;=');\n});\n\n// Find PDF documents with specific properties\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;filterByMimeType('application/pdf')\n          -&gt;filterByPropertyExists('title')\n          -&gt;filterByPropertyExists('author')\n          -&gt;filterByFileNameLike('report%');\n});\n\n// Find assets in a specific collection with a specific tag\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;whereCollection(DocumentsCollection::class)\n          -&gt;filterByPropertyContains('tags', 'important')\n          -&gt;filterByOrder(1);\n});\n\n// Find images that match specific criteria\n$model-&gt;filterAssets(function(AssetModel $model) {\n    $model-&gt;whereCollection(ImagesCollection::class)\n          -&gt;filterByNameLike('%profile%')\n          -&gt;filterBySize(500000, '&lt;=') // Less than 500KB\n          -&gt;filterByUpdatedAt(date('Y-m-d'), '='); // Updated today\n});</code></pre> <p>These examples demonstrate how you can combine multiple filters to create precise queries that match exactly what you're looking for.</p>"},{"location":"examples/#working-with-collections","title":"Working with Collections","text":"<p>You can retrieve assets from a specific collection:</p> <pre><code>// Get assets from a specific collection\n$assets = $user-&gt;getAssets(ImagesCollection::class);</code></pre>"},{"location":"examples/#adding-assets","title":"Adding Assets","text":"<p>You can add assets to an entity with various options:</p> <pre><code>// Create a File object from a local file path\n$file = new File('./images/placeholder.jpg');\n\n// For handling uploaded files from a request, use addAssetFromRequest instead\n// See the section on addAssetFromRequest in the Asset Adder documentation\n\n// Add the asset with various options\n$asset = $user-&gt;addAsset($file)\n    -&gt;usingFileName('test-placeholder.jpg') // Set a custom file name\n    -&gt;usingName('Test placeholder') // Set a display name\n    -&gt;setOrder(1) // Set the order\n    -&gt;preservingOriginal() // Keep the original file\n    -&gt;sanitizingFileName(static fn (string $filename): string =&gt; str_replace(['#', '/', '\\\\', ' '], '-', $filename)) // Sanitize the file name\n    -&gt;withCustomProperties([\n        'custom_property_1' =&gt; 'value1',\n        'custom_property_2' =&gt; 'value2',\n    ]) // Add custom properties\n    -&gt;toAssetCollection(null); // Save to the default collection</code></pre>"},{"location":"examples/#adding-to-a-specific-collection","title":"Adding to a Specific Collection","text":"<pre><code>// Add to a specific collection\n$asset = $user-&gt;addAsset($file)\n    -&gt;usingFileName('profile.jpg')\n    -&gt;toAssetCollection(ProfilePicturesCollection::class);</code></pre>"},{"location":"examples/#adding-with-a-single-custom-property","title":"Adding with a Single Custom Property","text":"<pre><code>// Add with a single custom property\n$asset = $user-&gt;addAsset($file)\n    -&gt;withCustomProperty('title', 'My Profile Picture')\n    -&gt;toAssetCollection(null);</code></pre>"},{"location":"examples/#retrieving-assets","title":"Retrieving Assets","text":"<p>There are several ways to retrieve assets:</p> <pre><code>// Get all assets for an entity\n$allAssets = $user-&gt;getAssets();\n\n// Get assets from a specific collection\n$profilePictures = $user-&gt;getAssets(ProfilePicturesCollection::class);\n\n// Get the first asset\n$firstAsset = $user-&gt;getFirstAsset();\n\n// Get the first asset from a specific collection\n$profilePicture = $user-&gt;getFirstAsset(ProfilePicturesCollection::class);\n\n// Get the last asset from a specific collection\n$lastDocument = $user-&gt;getLastAsset(DocumentsCollection::class);</code></pre>"},{"location":"examples/#deleting-assets","title":"Deleting Assets","text":"<p>You can delete assets from an entity:</p> <pre><code>// Delete all assets for an entity\n$user-&gt;deleteAssets();\n\n// Delete assets from a specific collection\n$user-&gt;deleteAssets(ImagesCollection::class);</code></pre>"},{"location":"examples/#working-with-asset-properties","title":"Working with Asset Properties","text":"<p>Once you have an asset, you can work with its properties:</p> <pre><code>// Get an asset\n$asset = $user-&gt;getFirstAsset();\n\n// Get the absolute path to the asset file\n$path = $asset-&gt;getAbsolutePath();\n\n// Get the URL to the asset file\n$url = $asset-&gt;getUrl();\n\n// Get the custom properties of the asset\n$properties = $asset-&gt;getCustomProperties();\n\n// Get a specific custom property\n$title = $asset-&gt;getCustomProperty('title');\n\n// Get the file name\n$fileName = $asset-&gt;getFileName();\n\n// Get the mime type\n$mimeType = $asset-&gt;getMimeType();\n\n// Get the size in bytes\n$size = $asset-&gt;getSize();\n\n// Get the human-readable size\n$readableSize = $asset-&gt;getHumanReadableSize();\n\n// Check if the asset is an image\nif ($asset-&gt;isImage()) {\n    // Do something with the image\n}\n\n// Check if the asset is a video\nif ($asset-&gt;isVideo()) {\n    // Do something with the video\n}\n\n// Check if the asset is a document\nif ($asset-&gt;isDocument()) {\n    // Do something with the document\n}</code></pre>"},{"location":"examples/#combining-multiple-filters","title":"Combining Multiple Filters","text":"<p>You can combine multiple filters to create complex queries:</p> <pre><code>// Find users with large profile pictures\n$users = model(User::class, false)\n    -&gt;filterAssets(function(AssetModel $model) {\n        $model-&gt;whereCollection(ProfilePicturesCollection::class)\n              -&gt;filterBySizeRange(1000000, PHP_INT_MAX) // Larger than 1MB\n              -&gt;filterByMimeType('image/jpeg');\n    })\n    -&gt;findAll();\n\n// Find users with recently updated documents\n$users = model(User::class, false)\n    -&gt;filterAssets(function(AssetModel $model) {\n        $model-&gt;whereCollection(DocumentsCollection::class)\n              -&gt;filterByUpdatedAt(date('Y-m-d', strtotime('-7 days')), '&gt;=');\n    })\n    -&gt;findAll();</code></pre>"},{"location":"examples/#advanced-example-image-gallery","title":"Advanced Example: Image Gallery","text":"<p>Here's a more complex example showing how to implement an image gallery:</p> <pre><code>// First, define custom collection classes for more control\nclass ImagesCollection implements AssetCollectionDefinitionInterface, AssetVariantsInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition\n            // Allow specific file extensions using the AssetExtension enum\n            -&gt;allowedExtensions(\n                AssetExtension::JPG,\n                AssetExtension::PNG,\n                AssetExtension::GIF,\n                AssetExtension::WEBP\n            )\n            // Alternatively, you can use the spread operator with AssetExtension::images()\n            // to allow all image extensions at once:\n            // -&gt;allowedExtensions(...AssetExtension::images())\n            // Allow specific MIME types using the AssetMimeType enum\n            -&gt;allowedMimeTypes(\n                AssetMimeType::IMAGE_JPEG,\n                AssetMimeType::IMAGE_PNG,\n                AssetMimeType::IMAGE_GIF,\n                AssetMimeType::IMAGE_WEBP\n            )\n            -&gt;setMaxFileSize(10 * 1024 * 1024); // 10MB\n    }\n\n    public function checkAuthorization(array|Entity $entity, Asset $asset): bool\n    {\n        return true;\n    }\n\n    public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void\n    {\n        // No variants needed as we'll create thumbnails separately\n    }\n}\n\nclass ThumbnailsCollection implements AssetCollectionDefinitionInterface, AssetVariantsInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition\n            // Allow specific file extensions using the AssetExtension enum\n            -&gt;allowedExtensions(\n                AssetExtension::JPG,\n                AssetExtension::PNG,\n                AssetExtension::GIF,\n                AssetExtension::WEBP\n            )\n            // Allow specific MIME types using the AssetMimeType enum\n            -&gt;allowedMimeTypes(\n                AssetMimeType::IMAGE_JPEG,\n                AssetMimeType::IMAGE_PNG,\n                AssetMimeType::IMAGE_GIF,\n                AssetMimeType::IMAGE_WEBP\n            )\n            -&gt;setMaxFileSize(2 * 1024 * 1024); // 2MB\n    }\n\n    public function checkAuthorization(array|Entity $entity, Asset $asset): bool\n    {\n        return true;\n    }\n\n    public function variants(CreateAssetVariantsInterface $variants, Asset $asset): void\n    {\n        // No variants needed for thumbnails\n    }\n}\n\n// In your entity class\nclass Gallery extends Entity\n{\n    use UseAssetConnectTrait;\n\n    public function setupAssetConnect(SetupAssetCollection $setup): void\n    {\n        // Set the default collection definition\n        // Note: Only one default collection can be set; additional calls will override previous ones\n        $setup-&gt;setDefaultCollectionDefinition(ImagesCollection::class);\n\n    }\n}\n\n// In your controller\npublic function uploadImage()\n{\n    $gallery = model(Gallery::class)-&gt;find($this-&gt;request-&gt;getPost('gallery_id'));\n\n    // Add the original image using addAssetFromRequest\n    $assetAdders = $gallery-&gt;addAssetFromRequest('image')\n        -&gt;forEach(function($uploadedFile, $assetAdder) {\n            $assetAdder\n                -&gt;usingFileName($uploadedFile-&gt;getRandomName())\n                -&gt;withCustomProperties([\n                    'title' =&gt; $this-&gt;request-&gt;getPost('title'),\n                    'description' =&gt; $this-&gt;request-&gt;getPost('description'),\n                    'tags' =&gt; explode(',', $this-&gt;request-&gt;getPost('tags')),\n                ]);\n        });\n\n    // Convert to assets and store in collection\n    $images = [];\n    foreach ($assetAdders as $assetAdder) {\n        $images[] = $assetAdder-&gt;toAssetCollection(ImagesCollection::class);\n    }\n\n    if (!empty($images)) {\n        return redirect()-&gt;to('gallery/' . $gallery-&gt;id);\n    }\n\n    return redirect()-&gt;back()-&gt;with('error', 'Failed to upload image');\n}\n\n// In your view\npublic function showGallery($id)\n{\n    $gallery = model(Gallery::class)-&gt;find($id);\n    $images = $gallery-&gt;getAssets(ImagesCollection::class);\n\n    return view('gallery', ['gallery' =&gt; $gallery, 'images' =&gt; $images]);\n}</code></pre>"},{"location":"examples/#conclusion","title":"Conclusion","text":"<p>These examples demonstrate the flexibility and power of CodeIgniter Asset Connect. You can use these patterns to implement complex asset management features in your application.</p> <p>For more advanced usage, check out the Advanced Usage guide.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>Before installing CodeIgniter Asset Connect, ensure your environment meets the following requirements:</p> <ul> <li>PHP 8.3 or higher</li> <li>CodeIgniter 4.6 or higher</li> <li>CodeIgniter Queue</li> <li>Composer</li> </ul>"},{"location":"installation/#installation-steps","title":"Installation Steps","text":""},{"location":"installation/#1-install-via-composer","title":"1. Install via Composer","text":"<p>You can install the package via Composer:</p> <pre><code>composer require maniaba/asset-connect</code></pre>"},{"location":"installation/#2-run-migrations","title":"2. Run Migrations","text":"<p>The library includes a migration to create the necessary database table for storing asset metadata. Run the migration using the following command:</p> <pre><code>php spark migrate --namespace=Maniaba\\\\AssetConnect</code></pre> <p>This will create the <code>assets</code> table in your database.</p>"},{"location":"installation/#3-configure-your-entities","title":"3. Configure Your Entities","text":"<p>To use Asset Connect with your entities, you need to add the <code>UseAssetConnectTrait</code> to any entity you want to associate files with:</p> <pre><code>&lt;?php\n\nnamespace App\\Entities;\n\nuse CodeIgniter\\Entity\\Entity;\nuse Maniaba\\AssetConnect\\Traits\\UseAssetConnectTrait;\nuse Maniaba\\AssetConnect\\AssetCollection\\Interfaces\\SetupAssetCollectionInterface;\n\nclass User extends Entity\n{\n    use UseAssetConnectTrait;\n\n    // You must implement this abstract method\n    public function setupAssetConnect(SetupAssetCollectionInterface $setup): void\n    {\n        // Set the default collection definition\n        // Note: Only one default collection can be set; additional calls will override previous ones\n        $setup-&gt;setDefaultCollectionDefinition(ImagesCollection::class);\n\n    }\n\n    // Your other entity methods...\n}</code></pre>"},{"location":"installation/#4-configure-your-models-optional","title":"4. Configure Your Models (Optional)","text":"<p>If you want to automatically load the Asset Connect functionality when retrieving entities from your models, you can add the <code>UseAssetConnectModelTrait</code> to your models:</p> <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse CodeIgniter\\Model;\nuse Maniaba\\AssetConnect\\Traits\\UseAssetConnectModelTrait;\n\nclass UserModel extends Model\n{\n    use UseAssetConnectModelTrait;\n\n    // Your model configuration...\n}</code></pre> <p>If your model already has an <code>initialize()</code> method, you need to use PHP's trait aliasing feature to avoid method conflicts:</p> <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse CodeIgniter\\Model;\nuse Maniaba\\AssetConnect\\Traits\\UseAssetConnectModelTrait;\n\nclass UserModel extends Model\n{\n    // Use the trait with method aliasing to avoid conflicts with existing initialize method\n    use UseAssetConnectModelTrait {\n        initialize as initializeAssetConnectModel;\n    }\n\n    protected function initialize(): void\n    {\n        // Call the trait's initialize method with its new alias\n        $this-&gt;initializeAssetConnectModel();\n\n        // Your existing initialize code...\n        // etc...\n    }\n\n    // Your other model methods...\n}</code></pre>"},{"location":"installation/#5-configure-entity-and-collection-definitions-required","title":"5. Configure Entity and Collection Definitions (Required)","text":"<p>This is a required step for Asset Connect to function properly.</p> <p>You must register your entity types and asset collections in the configuration file. Create or extend the <code>Config\\Asset.php</code> file in your application:</p> <pre><code>&lt;?php\n\nnamespace Config;\n\nuse App\\Entities\\User;\nuse App\\Entities\\Product;\nuse App\\AssetCollections\\ProfilePicturesCollection;\nuse App\\AssetCollections\\ProductImagesCollection;\nuse Maniaba\\AssetConnect\\Config\\Asset as BaseAssetConfig;\n\nclass Asset extends BaseAssetConfig\n{\n    /**\n     * REQUIRED: Define entity types and their unique identifiers\n     * Every entity that uses UseAssetConnectTrait must be registered here\n     */\n    public array $entityKeyDefinitions = [\n        User::class =&gt; 'user',\n        Product::class =&gt; 'product',\n    ];\n\n    /**\n     * REQUIRED: Define collection definitions and their unique identifiers\n     * Every asset collection class you create must be registered here\n     */\n    public array $collectionKeyDefinitions = [\n        ProfilePicturesCollection::class =&gt; 'profile_pictures',\n        ProductImagesCollection::class =&gt; 'product_images',\n    ];\n}</code></pre> <p>Why this is required:</p> <ul> <li>Asset Connect uses these identifiers to store and retrieve asset associations</li> <li>Without these definitions, the library cannot identify which entity or collection an asset belongs to</li> <li>These mappings are stored in the database and are essential for data integrity</li> <li>They enable proper querying and filtering of assets by type</li> </ul> <p>Important: You must add every entity and collection to these arrays as you create them. Failure to do so will prevent Asset Connect from working with those entities or collections.</p> <p>For more details, see the Configuration documentation.</p>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>After installation, you may want to:</p> <ol> <li>Configure the library to customize its behavior</li> <li>Learn about basic usage to start working with assets</li> </ol>"},{"location":"pending-asset-manager/","title":"Pending Asset Manager","text":"<p>The <code>PendingAssetManager</code> class provides a high-level API for managing pending assets. It handles storing, retrieving, and deleting pending assets, as well as managing their lifecycle and expiration.</p>"},{"location":"pending-asset-manager/#overview","title":"Overview","text":"<p><code>PendingAssetManager</code> acts as a facade over the configured <code>PendingStorageInterface</code> implementation, providing a simple and consistent interface for working with pending assets.</p> <p>Namespace: <code>Maniaba\\AssetConnect\\Pending\\PendingAssetManager</code></p>"},{"location":"pending-asset-manager/#creating-an-instance","title":"Creating an Instance","text":"<pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAssetManager;\n\n// Using default storage from configuration\n$manager = PendingAssetManager::make();\n\n// Using custom storage\n$customStorage = new MyCustomPendingStorage();\n$manager = PendingAssetManager::make($customStorage);</code></pre>"},{"location":"pending-asset-manager/#methods","title":"Methods","text":""},{"location":"pending-asset-manager/#make","title":"make()","text":"<p>Creates a new instance of <code>PendingAssetManager</code>.</p> <pre><code>public static function make(?PendingStorageInterface $storage = null): PendingAssetManager</code></pre> <p>Parameters: - <code>$storage</code> - Optional custom pending storage implementation. If null, uses the storage configured in <code>app/Config/Asset.php</code></p> <p>Returns: New <code>PendingAssetManager</code> instance</p> <p>Example: <pre><code>// Default storage\n$manager = PendingAssetManager::make();\n\n// Custom storage\nuse App\\Storage\\S3PendingStorage;\n$manager = PendingAssetManager::make(new S3PendingStorage());</code></pre></p>"},{"location":"pending-asset-manager/#store","title":"store()","text":"<p>Stores a pending asset. If the asset doesn't have an ID, generates a new one and stores both file and metadata. If the asset already has an ID, updates only the metadata.</p> <pre><code>public function store(PendingAsset $pendingAsset, ?int $ttlSeconds = null): void</code></pre> <p>Parameters: - <code>$pendingAsset</code> - The pending asset to store - <code>$ttlSeconds</code> - Optional TTL in seconds (overrides default if provided)</p> <p>Throws: - <code>PendingAssetException</code> - If unable to store the asset - <code>RandomException</code> - If unable to generate unique ID</p> <p>Examples:</p>"},{"location":"pending-asset-manager/#store-new-pending-asset","title":"Store new pending asset","text":"<pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAsset;\nuse Maniaba\\AssetConnect\\Pending\\PendingAssetManager;\n\n$pending = PendingAsset::createFromFile('/path/to/photo.jpg');\n$pending-&gt;usingName('Profile Photo');\n\n$manager = PendingAssetManager::make();\n$manager-&gt;store($pending);\n\n// ID is now available\n$pendingId = $pending-&gt;id;</code></pre>"},{"location":"pending-asset-manager/#store-with-custom-ttl","title":"Store with custom TTL","text":"<pre><code>$pending = PendingAsset::createFromFile('/path/to/document.pdf');\n\n// Store with 1 hour TTL instead of default 24 hours\n$manager = PendingAssetManager::make();\n$manager-&gt;store($pending, 3600);</code></pre>"},{"location":"pending-asset-manager/#update-metadata-only","title":"Update metadata only","text":"<pre><code>// Fetch existing pending asset\n$manager = PendingAssetManager::make();\n$pending = $manager-&gt;fetchById($existingId);\n\n// Update metadata\n$pending-&gt;withCustomProperty('status', 'reviewed');\n$pending-&gt;usingName('Updated Name');\n\n// Store - only updates metadata.json, file remains unchanged\n$manager-&gt;store($pending);</code></pre>"},{"location":"pending-asset-manager/#fetchbyid","title":"fetchById()","text":"<p>Fetches a pending asset by its ID. Returns <code>null</code> if not found or expired.</p> <pre><code>public function fetchById(string $id): ?PendingAsset</code></pre> <p>Parameters: - <code>$id</code> - Unique identifier of the pending asset</p> <p>Returns: <code>PendingAsset</code> object if found and not expired, <code>null</code> otherwise</p> <p>Throws: - <code>PendingAssetException</code> - If unable to read metadata</p> <p>Example: <pre><code>$manager = PendingAssetManager::make();\n\n$pending = $manager-&gt;fetchById('a1b2c3d4e5f6');\n\nif ($pending === null) {\n    // Asset not found or expired\n    echo \"Pending asset not found\";\n} else {\n    // Use the asset\n    echo $pending-&gt;name;\n    echo $pending-&gt;file_name;\n}</code></pre></p> <p>Automatic Expiration Handling:</p> <p>The method automatically checks if the asset has expired by comparing <code>created_at + ttl</code> with the current time. If expired: 1. Attempts to delete the expired asset 2. Returns <code>null</code></p> <pre><code>$manager = PendingAssetManager::make();\n$pending = $manager-&gt;fetchById($id);\n\n// If returned null, either:\n// 1. ID doesn't exist\n// 2. Asset has expired (and was automatically deleted)\nif ($pending === null) {\n    return response()-&gt;json(['error' =&gt; 'Asset not found or expired'], 404);\n}</code></pre>"},{"location":"pending-asset-manager/#deletebyid","title":"deleteById()","text":"<p>Deletes a pending asset by its ID.</p> <pre><code>public function deleteById(string $id): bool</code></pre> <p>Parameters: - <code>$id</code> - Unique identifier of the pending asset to delete</p> <p>Returns: <code>true</code> if deleted successfully, <code>false</code> otherwise</p> <p>Example: <pre><code>$manager = PendingAssetManager::make();\n\n$success = $manager-&gt;deleteById($pendingId);\n\nif ($success) {\n    echo \"Asset deleted successfully\";\n} else {\n    echo \"Failed to delete asset or asset not found\";\n}</code></pre></p> <p>Note: When using <code>addAssetFromPending()</code>, pending assets are automatically cleaned up after successful addition to an entity.</p>"},{"location":"pending-asset-manager/#cleanexpiredpendingassets","title":"cleanExpiredPendingAssets()","text":"<p>Manually triggers cleanup of all expired pending assets.</p> <pre><code>public function cleanExpiredPendingAssets(): void</code></pre> <p>Example: <pre><code>$manager = PendingAssetManager::make();\n$manager-&gt;cleanExpiredPendingAssets();\n\necho \"Expired assets cleaned\";</code></pre></p> <p>Automatic Cleanup:</p> <p>Expired pending assets are automatically cleaned up by the <code>AssetConnectJob</code> queue job. When assets are processed, the job also handles cleanup of expired pending assets from the default pending storage. This ensures that temporary files don't accumulate over time.</p> <p>If you need to manually trigger cleanup outside of the queue job, you can use the method shown above.</p>"},{"location":"pending-asset-manager/#complete-usage-examples","title":"Complete Usage Examples","text":""},{"location":"pending-asset-manager/#example-1-simple-upload-flow","title":"Example 1: Simple Upload Flow","text":"<pre><code>// Upload endpoint\npublic function upload()\n{\n    $file = $this-&gt;request-&gt;getFile('photo');\n\n    $pending = PendingAsset::createFromFile($file);\n    $pending-&gt;usingName('User Photo');\n\n    $manager = PendingAssetManager::make();\n    $manager-&gt;store($pending);\n\n    return $this-&gt;response-&gt;setJSON([\n        'pending_id' =&gt; $pending-&gt;id\n    ]);\n}\n\n// Confirm endpoint\npublic function confirm()\n{\n    $pendingId = $this-&gt;request-&gt;getPost('pending_id');\n\n    $manager = PendingAssetManager::make();\n    $pending = $manager-&gt;fetchById($pendingId);\n\n    if (!$pending) {\n        return $this-&gt;response-&gt;setStatusCode(404);\n    }\n\n    // Add to entity\n    $user-&gt;addAssetFromPending($pending)\n        -&gt;toAssetCollection(Photos::class);\n\n    // Clean up\n    $manager-&gt;deleteById($pendingId);\n\n    return $this-&gt;response-&gt;setJSON(['success' =&gt; true]);\n}</code></pre>"},{"location":"pending-asset-manager/#example-2-multi-step-upload-with-metadata-editing","title":"Example 2: Multi-step Upload with Metadata Editing","text":"<pre><code>// Step 1: Upload file\npublic function uploadFile()\n{\n    $file = $this-&gt;request-&gt;getFile('file');\n\n    $pending = PendingAsset::createFromFile($file);\n\n    $manager = PendingAssetManager::make();\n    $manager-&gt;store($pending);\n\n    return $this-&gt;response-&gt;setJSON([\n        'pending_id' =&gt; $pending-&gt;id,\n        'file_name' =&gt; $pending-&gt;file_name,\n        'size' =&gt; $pending-&gt;size\n    ]);\n}\n\n// Step 2: Edit metadata\npublic function updateMetadata()\n{\n    $pendingId = $this-&gt;request-&gt;getPost('pending_id');\n    $name = $this-&gt;request-&gt;getPost('name');\n    $alt = $this-&gt;request-&gt;getPost('alt');\n\n    $manager = PendingAssetManager::make();\n    $pending = $manager-&gt;fetchById($pendingId);\n\n    if (!$pending) {\n        return $this-&gt;response-&gt;setStatusCode(404);\n    }\n\n    // Update metadata (file remains unchanged)\n    $pending-&gt;usingName($name)\n        -&gt;withCustomProperty('alt', $alt);\n\n    $manager-&gt;store($pending);\n\n    return $this-&gt;response-&gt;setJSON(['success' =&gt; true]);\n}\n\n// Step 3: Confirm and attach\npublic function confirmUpload()\n{\n    $pendingId = $this-&gt;request-&gt;getPost('pending_id');\n\n    $manager = PendingAssetManager::make();\n    $pending = $manager-&gt;fetchById($pendingId);\n\n    if (!$pending) {\n        return $this-&gt;response-&gt;setStatusCode(404);\n    }\n\n    $user-&gt;addAssetFromPending($pending)\n        -&gt;toAssetCollection(Images::class);\n\n    return $this-&gt;response-&gt;setJSON(['success' =&gt; true]);\n}</code></pre>"},{"location":"pending-asset-manager/#example-3-batch-upload","title":"Example 3: Batch Upload","text":"<pre><code>public function batchUpload()\n{\n    $result = PendingAsset::createFromRequest('photos');\n\n    if (empty($result['photos'])) {\n        return $this-&gt;response-&gt;setStatusCode(400)\n            -&gt;setJSON(['error' =&gt; 'No files uploaded']);\n    }\n\n    $manager = PendingAssetManager::make();\n    $pendingIds = [];\n\n    foreach ($result['photos'] as $pending) {\n        $manager-&gt;store($pending);\n\n        $pendingIds[] = $pending-&gt;id;\n    }\n\n    return $this-&gt;response-&gt;setJSON([\n        'pending_ids' =&gt; $pendingIds\n    ]);\n}\n\npublic function confirmBatch()\n{\n    $pendingIds = $this-&gt;request-&gt;getPost('pending_ids');\n    $manager = PendingAssetManager::make();\n\n    foreach ($pendingIds as $pendingId) {\n        $pending = $manager-&gt;fetchById($pendingId);\n\n        if (!$pending) {\n            continue; // Skip expired or invalid\n        }\n\n        $product-&gt;addAssetFromPending($pending)\n            -&gt;toAssetCollection(ProductImages::class);\n    }\n\n    return $this-&gt;response-&gt;setJSON(['success' =&gt; true]);\n}</code></pre>"},{"location":"pending-asset-manager/#error-handling","title":"Error Handling","text":""},{"location":"pending-asset-manager/#handling-expired-assets","title":"Handling Expired Assets","text":"<pre><code>$manager = PendingAssetManager::make();\n$pending = $manager-&gt;fetchById($pendingId);\n\nif ($pending === null) {\n    return $this-&gt;response-&gt;setStatusCode(410) // 410 Gone\n        -&gt;setJSON([\n            'error' =&gt; 'This upload has expired. Please upload again.',\n            'code' =&gt; 'ASSET_EXPIRED'\n        ]);\n}</code></pre>"},{"location":"pending-asset-manager/#handling-storage-errors","title":"Handling Storage Errors","text":"<pre><code>try {\n    $manager = PendingAssetManager::make();\n    $manager-&gt;store($pending);\n} catch (PendingAssetException $e) {\n    log_message('error', 'Failed to store pending asset: ' . $e-&gt;getMessage());\n\n    return $this-&gt;response-&gt;setStatusCode(500)\n        -&gt;setJSON([\n            'error' =&gt; 'Failed to store file. Please try again.',\n            'code' =&gt; 'STORAGE_ERROR'\n        ]);\n}</code></pre>"},{"location":"pending-asset-manager/#validation-before-storing","title":"Validation Before Storing","text":"<pre><code>try {\n    // createFromRequest automatically validates uploaded files\n    $result = PendingAsset::createFromRequest('photo');\n\n    if (empty($result['photo'])) {\n        throw new \\RuntimeException('No file uploaded');\n    }\n\n    $pending = $result['photo'][0];\n\n    // Additional validation\n    if ($pending-&gt;size &gt; 10 * 1024 * 1024) { // 10MB\n        throw new \\RuntimeException('File too large');\n    }\n\n    $allowedMimes = ['image/jpeg', 'image/png', 'image/gif'];\n    if (!in_array($pending-&gt;mime_type, $allowedMimes)) {\n        throw new \\RuntimeException('Invalid file type');\n    }\n\n    // Now safe to store\n    $manager = PendingAssetManager::make();\n    $manager-&gt;store($pending);\n\n} catch (\\Exception $e) {\n    return $this-&gt;response-&gt;setStatusCode(400)\n        -&gt;setJSON(['error' =&gt; $e-&gt;getMessage()]);\n}</code></pre>"},{"location":"pending-asset-manager/#best-practices","title":"Best Practices","text":""},{"location":"pending-asset-manager/#1-pending-assets-are-auto-cleaned","title":"1. Pending Assets Are Auto-Cleaned","text":"<pre><code>// Pending assets are automatically cleaned up after successful addition\n$user-&gt;addAssetFromPending($pendingId)\n    -&gt;toAssetCollection(Photos::class);\n// File is automatically removed from pending storage</code></pre>"},{"location":"pending-asset-manager/#2-check-for-expiration","title":"2. Check for Expiration","text":"<pre><code>// Good \u2713\n$pending = $manager-&gt;fetchById($id);\nif (!$pending) {\n    return response()-&gt;json(['error' =&gt; 'Expired'], 410);\n}\n\n// Bad \u2717\n$pending = $manager-&gt;fetchById($id);\n$user-&gt;addAssetFromPending($pending)-&gt;save(); // May be null!</code></pre>"},{"location":"pending-asset-manager/#3-use-appropriate-ttl","title":"3. Use Appropriate TTL","text":"<pre><code>// Short-lived uploads (e.g., profile picture)\n$manager-&gt;store($pending, 1800); // 30 minutes\n\n// Long-lived uploads (e.g., document approval workflow)\n$manager-&gt;store($pending, 86400 * 7); // 7 days</code></pre> <p>Note: Expired pending assets are automatically cleaned up by the <code>AssetConnectJob</code> queue job when processing assets. No additional setup is required for automatic cleanup.</p>"},{"location":"pending-asset-manager/#configuration","title":"Configuration","text":"<p>The default pending storage is configured in <code>app/Config/Asset.php</code>:</p> <pre><code>use Maniaba\\AssetConnect\\Pending\\DefaultPendingStorage;\n\nclass Asset extends BaseConfig\n{\n    public string $pendingStorage = DefaultPendingStorage::class;\n}</code></pre> <p>To use a custom storage implementation:</p> <pre><code>use App\\Storage\\CustomPendingStorage;\n\nclass Asset extends BaseConfig\n{\n    public string $pendingStorage = CustomPendingStorage::class;\n}</code></pre>"},{"location":"pending-asset-manager/#see-also","title":"See Also","text":"<ul> <li>Pending Assets - Overview of pending assets functionality</li> <li>DefaultPendingStorage - Default filesystem storage implementation</li> <li>Custom Pending Storage - Creating custom storage implementations</li> </ul>"},{"location":"pending-security-token/","title":"Pending Security Tokens","text":"<p>This page documents the pending asset security token subsystem: what it is, why it exists, available strategies, configuration options, and usage examples.</p>"},{"location":"pending-security-token/#what-is-a-pending-security-token","title":"What is a pending security token?","text":"<p>A pending security token is a short-lived opaque value associated with a pending asset. It helps protect access to pending files and ensures that only the actor that created the pending asset (or a trusted flow that received the token) can access, confirm, or convert the pending asset into a permanent asset.</p> <p>Tokens are intentionally short-lived (configurable TTL) and are compared using a timing-safe comparison to avoid leaking information via timing attacks.</p>"},{"location":"pending-security-token/#why-use-security-tokens","title":"Why use security tokens?","text":"<ul> <li>Prevents accidental or malicious access to pending files by ID alone.</li> <li>Makes it safe to expose pending IDs to clients, since the token is required to confirm/convert the pending asset.</li> <li>Supports multiple storage strategies (session, cookie, headers, signed URLs, database) depending on your application's architecture.</li> </ul>"},{"location":"pending-security-token/#configuration-asset-config","title":"Configuration (Asset config)","text":"<p>The <code>Asset</code> configuration exposes a <code>pendingSecurityToken</code> option where you can set the concrete class used to manage tokens:</p> <ul> <li><code>\\Maniaba\\AssetConnect\\Pending\\PendingSecurityToken\\SessionPendingSecurityToken</code> (default) \u2014 stores tokens in the active session using tempdata.</li> <li><code>CookiePendingSecurityToken</code> \u2014 (documented here as an option) stores tokens in cookies.</li> <li><code>null</code> \u2014 disables security token validation; pending assets will not be protected by tokens.</li> </ul> <p>Example (default config):</p> <pre><code>// src/Config/Asset.php\npublic ?string $pendingSecurityToken = \\Maniaba\\AssetConnect\\Pending\\PendingSecurityToken\\SessionPendingSecurityToken::class;</code></pre> <p>Set this to <code>null</code> to disable the token subsystem.</p>"},{"location":"pending-security-token/#available-interfaces-and-base-class","title":"Available interfaces and base class","text":"<ul> <li><code>Maniaba\\AssetConnect\\Pending\\Interfaces\\PendingSecurityTokenInterface</code> \u2014 interface that any token strategy must implement. Public methods:</li> <li><code>generateToken(string $pendingId): string</code> \u2014 generate and persist a token for the given pending ID and return the token.</li> <li><code>retrieveToken(string $pendingId): ?string</code> \u2014 retrieve the token for the given pending ID from the chosen strategy (session, cookie, header, etc.).</li> <li><code>validateToken(PendingAsset $pendingAsset, ?string $tokenProvided = null): bool</code> \u2014 validate the provided (or retrieved) token against the pending asset's stored <code>security_token</code> value.</li> <li> <p><code>deleteToken(string $pendingId): void</code> \u2014 remove stored token data for cleanup.</p> </li> <li> <p><code>Maniaba\\AssetConnect\\Pending\\PendingSecurityToken\\AbstractPendingSecurityToken</code> \u2014 provides common behavior:</p> </li> <li>Validates constructor parameters: positive TTL and token length between 1 and 64 bytes.</li> <li><code>randomStringToken()</code> \u2014 uses <code>random_bytes()</code> and <code>bin2hex()</code> to build a cryptographically random token. May throw randomness-related exceptions.</li> <li><code>validateToken()</code> \u2014 default validation uses <code>retrieveToken()</code> when the token is not passed explicitly and compares using <code>hash_equals()</code>.</li> <li>Requires concrete classes to implement <code>initialize()</code> where service wiring (for example, session) is performed.</li> </ul>"},{"location":"pending-security-token/#default-implementation-sessionpendingsecuritytoken","title":"Default implementation: SessionPendingSecurityToken","text":"<p>Namespace: <code>Maniaba\\AssetConnect\\Pending\\PendingSecurityToken\\SessionPendingSecurityToken</code></p> <p>Behavior and notes:</p> <ul> <li>Stores tokens in CodeIgniter session tempdata with a key: <code>__pending_asset_security_token_{pendingId}</code>.</li> <li>Constructor parameters: token TTL (seconds) and token byte length.</li> <li><code>generateToken($pendingId)</code> \u2014 generates a token, stores it in session tempdata (with TTL), and returns the token string.</li> <li><code>retrieveToken($pendingId)</code> \u2014 reads session tempdata for the key and returns the token or <code>null</code>.</li> <li><code>deleteToken($pendingId)</code> \u2014 removes tempdata for cleanup.</li> <li><code>initialize()</code> loads the <code>session</code> service and throws <code>InvalidArgumentException</code> if the session service is not available.</li> </ul> <p>This strategy is appropriate when you control the user's browser session (typical web app). The token lives in server-side session storage and is accessible only to the same session that received it.</p>"},{"location":"pending-security-token/#other-strategies","title":"Other strategies","text":"<ul> <li>Cookie-backed tokens: store the token in an HTTP-only cookie scoped for the upload/confirm routes. This is useful for stateless endpoints when you still want the browser to carry the token.</li> <li>Header-based tokens: the client stores the token (for example in a JS variable) and includes it in a custom header when confirming the pending asset.</li> <li>Signed URLs / DB storage: for advanced scenarios you can implement a strategy that persists tokens in a database table or issues short-lived signed URLs.</li> </ul> <p>To use a different strategy, implement <code>PendingSecurityTokenInterface</code> and change <code>Config\\Asset::$pendingSecurityToken</code> to your class.</p>"},{"location":"pending-security-token/#usage-examples","title":"Usage examples","text":"<p>Important: tokens are generated automatically when you persist a pending asset through <code>PendingAsset::store()</code> (which delegates to <code>PendingAssetManager::store()</code>). The manager will call the configured token provider's <code>generateToken($pendingId)</code> and set the returned token on the <code>PendingAsset</code> instance (<code>$pending-&gt;security_token</code>). You typically do not need to call <code>generateToken()</code> yourself.</p> <p>1) Upload flow \u2014 store pending asset and return the generated token to the client:</p> <pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAsset;\n\n$result = PendingAsset::createFromRequest('file');\n$pending = $result['file'][0];\n\n// Persist pending asset. PendingAssetManager::store() will generate a token\n$pending-&gt;store();\n\n// Token (if token provider is configured) is available on the PendingAsset object\nreturn $this-&gt;response-&gt;setJSON([\n    'pending_id' =&gt; $pending-&gt;id,\n    'security_token' =&gt; $pending-&gt;security_token, // may be null if no provider\n]);</code></pre> <p>2) Token validation when confirming/adding a pending asset</p> <p>Token validation is performed by <code>PendingAssetManager::fetchById(string $id, ?string $token = null): ?PendingAsset</code>. If a token provider is configured, <code>fetchById()</code> will call the provider's <code>validateToken()</code> internally. When validation fails (or asset is missing/expired) <code>fetchById()</code> returns <code>null</code>.</p> <p>Examples below demonstrate two patterns:</p> <pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAssetManager;\n\n$manager = PendingAssetManager::make();\n\n// 1) Explicit token provided by the client (e.g. POST body).\n// Pass the token into fetchById(); if it's invalid, you'll get null.\n$pending = $manager-&gt;fetchById($pendingId, $providedTokenFromClient);\n\nif ($pending === null) {\n    // Asset not found, expired, or token invalid\n    throw new \\RuntimeException('Pending asset not found or invalid security token.');\n}\n\n// proceed to add asset from pending\n\n// 2) Let the configured provider retrieve the token itself (no explicit token passed).\n// For example, SessionPendingSecurityToken will read tempdata from the session.\n$pending = $manager-&gt;fetchById($pendingId);\n\nif ($pending === null) {\n    // Asset not found, expired, or provider failed to validate token\n    throw new \\RuntimeException('Pending asset not found or invalid/expired token.');\n}\n\n// proceed to add asset from pending</code></pre> <p>Notes:</p> <ul> <li>If <code>Config\\\\Asset::$pendingSecurityToken</code> is <code>null</code>, token generation and validation are disabled and <code>fetchById()</code> behaves as a normal read (subject to expiry checks).</li> <li>If you need to perform provider-level deletion of token material after consumption, call the provider's <code>deleteToken($pendingId)</code> directly (e.g. via the configured provider instance).</li> </ul> <p>3) Cleaning up tokens</p> <p>After you have confirmed and consumed a pending asset, you may call <code>deleteToken($pendingId)</code> to remove any stored token material from the provider (session, cookie, DB, ...):</p> <pre><code>$tokener-&gt;deleteToken($pending-&gt;id);</code></pre> <p>Notes:</p> <ul> <li>If <code>Config\\Asset::$pendingSecurityToken</code> is <code>null</code>, the manager will not generate a token and token validation will be skipped.</li> <li>If you need to manually generate tokens for special flows, you can call the provider's <code>generateToken()</code> directly \u2014 but be aware you must also persist/return the token to the client in your flow.</li> </ul>"},{"location":"pending-security-token/#constructor-options-and-robustness","title":"Constructor options and robustness","text":"<p><code>AbstractPendingSecurityToken</code> constructor accepts two parameters:</p> <ul> <li><code>$tokenTTLSeconds</code> (int) \u2014 how long the token persists in the chosen strategy. Must be &gt; 0.</li> <li><code>$tokenLength</code> (int) \u2014 number of random bytes used to generate the token (converted to hex), must be between 1 and 64.</li> </ul> <p>The constructor will throw an <code>InvalidArgumentException</code> if parameters are invalid.</p> <p><code>randomStringToken()</code> may throw randomness-related exceptions if the system cannot generate secure random bytes.</p>"},{"location":"pending-security-token/#security-considerations","title":"Security considerations","text":"<ul> <li>Always use <code>hash_equals()</code> (the abstract implementation does) when comparing tokens to avoid timing attacks.</li> <li>Keep TTL small for sensitive workflows.</li> <li>If storing tokens in cookies, use HttpOnly, Secure, SameSite attributes and consider rotating tokens.</li> <li>Avoid exposing tokens in URLs unless they are single-use and short-lived.</li> </ul>"},{"location":"pending/","title":"Pending Assets","text":"<p>Pending assets allow temporary storage of files and their metadata before final attachment to an entity. This functionality is especially useful for upload flows where a user first uploads a file, and later confirms where the asset will be added and with which settings.</p>"},{"location":"pending/#what-are-pending-assets","title":"What are Pending Assets?","text":"<p>A pending asset represents a temporary file that is not yet permanently attached to an entity in your application. Each pending asset contains:</p> <ul> <li>The actual file stored on disk</li> <li>Metadata about the asset (name, custom properties, order, preserve_original)</li> <li>Expiration time (TTL - Time To Live)</li> <li>A unique ID for identification</li> </ul> <p>Pending assets are stored in a temporary directory and automatically deleted after the TTL expires (default 24 hours).</p>"},{"location":"pending/#where-are-pending-assets-stored","title":"Where are Pending Assets Stored?","text":"<p>The default storage (<code>DefaultPendingStorage</code>) uses the filesystem to store pending assets. The directory structure is as follows:</p> <pre><code>WRITEPATH/assets_pending/\n\u251c\u2500\u2500 &lt;pendingId&gt;/\n\u2502   \u251c\u2500\u2500 file              # Raw file\n\u2502   \u2514\u2500\u2500 metadata.json     # Metadata in JSON format</code></pre> <p>Example: <pre><code>writable/assets_pending/\n\u251c\u2500\u2500 a1b2c3d4e5f6/\n\u2502   \u251c\u2500\u2500 file              # profile.jpg\n\u2502   \u2514\u2500\u2500 metadata.json     # {\"id\":\"a1b2c3d4e5f6\",\"name\":\"Profile Photo\",...}</code></pre></p> <p>Default expiration time (TTL): 86400 seconds (24 hours)</p> <p>After an asset expires (<code>created_at + ttl &lt; now</code>), <code>PendingAssetManager::fetchById()</code> will return <code>null</code> and attempt to automatically delete the expired asset.</p>"},{"location":"pending/#main-classes","title":"Main Classes","text":""},{"location":"pending/#pendingasset","title":"PendingAsset","text":"<p>A class that represents a pending asset. Contains the file and metadata.</p> <p>Namespace: <code>Maniaba\\AssetConnect\\Pending\\PendingAsset</code></p> <p>Properties:</p> Property Type Description <code>id</code> string Unique identifier for the pending asset <code>name</code> string Display name of the asset <code>file_name</code> string File name <code>mime_type</code> string MIME type of the file <code>size</code> int File size in bytes <code>ttl</code> int Time to live in seconds <code>created_at</code> Time Creation time <code>updated_at</code> Time Last modification time <code>order</code> int Asset order <code>preserve_original</code> bool Whether to preserve the original file <code>custom_properties</code> array Additional custom properties <code>file</code> File|UploadedFile Reference to the actual file <code>security_token</code> string|null Short-lived security token assigned to the pending asset (set by PendingAssetManager when a token provider is configured)"},{"location":"pending/#available-methods","title":"Available Methods","text":"Method Description <code>usingName(string $name)</code> Sets the display name of the asset <code>usingFileName(string $fileName)</code> Sets the file name <code>preservingOriginal(bool $preserve = true)</code> Sets whether to preserve the original <code>setOrder(int $order)</code> Sets the order <code>withCustomProperty(string $key, mixed $value)</code> Adds a single custom property <code>withCustomProperties(array $properties)</code> Sets all custom properties <code>setId(string $id)</code> Sets the ID (usually internal) <code>setTTL(int $ttl)</code> Sets the time to live in seconds <code>store(?PendingStorageInterface $storage = null, ?int $ttlSeconds = null)</code> Stores the pending asset. If ID exists, updates metadata only; if no ID, creates new storage. Optional custom storage and TTL parameters. <code>setSecurityToken(?string $token)</code> Sets the security token on the <code>PendingAsset</code> (used internally by <code>PendingAssetManager</code>/storage after token generation)"},{"location":"pending/#creation-methods-static","title":"Creation Methods (Static)","text":"Method Description <code>createFromFile(File\\|string\\|UploadedFile $file, array\\|string $attributes = [])</code> Creates a pending asset from a file object, file path, or uploaded file <code>createFromBase64(string $base64data, array\\|string $attributes = [])</code> Creates a pending asset from base64 encoded string <code>createFromString(string $string, array\\|string $attributes = [])</code> Creates a pending asset from string content (e.g., downloaded file content) <code>createFromRequest(string ...$keyNames)</code> Creates pending assets from HTTP request uploaded files (returns array grouped by field name)"},{"location":"pending/#pending-asset-manager","title":"Pending Asset Manager","text":"<p>Manager class for working with pending assets. Provides a high-level API for storing, fetching, and deleting.</p> <p>Namespace: <code>Maniaba\\AssetConnect\\Pending\\PendingAssetManager</code></p> <p>For detailed documentation, see Pending Asset Manager.</p>"},{"location":"pending/#defaultpendingstorage","title":"DefaultPendingStorage","text":"<p>Default filesystem implementation for storing pending assets.</p> <p>Namespace: <code>Maniaba\\AssetConnect\\Pending\\DefaultPendingStorage</code></p>"},{"location":"pending/#creating-pending-assets","title":"Creating Pending Assets","text":"<p>Pending assets are created using factory methods of the <code>PendingAsset</code> class.</p>"},{"location":"pending/#createfromfile","title":"createFromFile","text":"<p>Creates a pending asset from a file.</p> <pre><code>public static function createFromFile(\n    File|string|UploadedFile $file,\n    array|string $attributes = []\n): PendingAsset</code></pre> <p>Parameters: - <code>$file</code> - File (File object, path as string, or UploadedFile) - <code>$attributes</code> - Optional attributes as array or JSON string</p> <p>Example: <pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAsset;\n\n// From path\n$pending = PendingAsset::createFromFile('/path/to/photo.jpg');\n\n// From File object\n$file = new \\CodeIgniter\\Files\\File('/path/to/document.pdf');\n$pending = PendingAsset::createFromFile($file);\n\n// From UploadedFile (from form)\n$uploadedFile = $this-&gt;request-&gt;getFile('avatar');\n$pending = PendingAsset::createFromFile($uploadedFile);\n\n// With attributes\n$pending = PendingAsset::createFromFile('/path/to/photo.jpg', [\n    'name' =&gt; 'Profile Photo',\n    'order' =&gt; 1,\n    'custom_properties' =&gt; ['alt' =&gt; 'Photo description']\n]);</code></pre></p>"},{"location":"pending/#createfromstring","title":"createFromString","text":"<p>Creates a pending asset from a string.</p> <pre><code>public static function createFromString(\n    string $string,\n    array|string $attributes = []\n): PendingAsset</code></pre> <p>Example: <pre><code>$content = file_get_contents('http://example.com/image.jpg');\n$pending = PendingAsset::createFromString($content, [\n    'file_name' =&gt; 'downloaded-image.jpg'\n]);</code></pre></p>"},{"location":"pending/#createfrombase64","title":"createFromBase64","text":"<p>Creates a pending asset from a base64 encoded string.</p> <pre><code>public static function createFromBase64(\n    string $base64data,\n    array|string $attributes = []\n): PendingAsset</code></pre> <p>Example: <pre><code>// Base64 string from JavaScript\n$base64 = $_POST['image_data']; // \"data:image/png;base64,iVBORw0KG...\"\n\n// Remove data URI prefix if present\n$base64 = preg_replace('/^data:image\\/\\w+;base64,/', '', $base64);\n\n$pending = PendingAsset::createFromBase64($base64, [\n    'file_name' =&gt; 'screenshot.png',\n    'name' =&gt; 'Screenshot'\n]);</code></pre></p>"},{"location":"pending/#createfromrequest","title":"createFromRequest","text":"<p>Creates pending assets directly from HTTP request uploaded files. This is the recommended method for handling file uploads from forms.</p> <pre><code>public static function createFromRequest(string ...$keyNames): array</code></pre> <p>Parameters: - <code>...$keyNames</code> - One or more field names from the request to process</p> <p>Returns: Array of pending assets grouped by field name: <code>['fieldName' =&gt; [PendingAsset, ...]]</code></p> <p>Throws:</p> <ul> <li><code>InvalidArgumentException</code> if no key names are provided</li> <li><code>FileException</code> if uploaded file is invalid</li> </ul> <p>Features:</p> <ul> <li>Automatically handles both single and multiple file uploads</li> <li>Only processes specified field names (ignores other files)</li> <li>Validates uploaded files before creating pending assets</li> <li>Returns empty array if specified fields don't exist or contain no files</li> </ul> <p>Example - Single file upload: <pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAsset;\n\n// HTML: &lt;input type=\"file\" name=\"avatar\"&gt;\n\n// Process uploaded file\n$result = PendingAsset::createFromRequest('avatar');\n\nif (!empty($result['avatar'])) {\n    $pending = $result['avatar'][0]; // Get first (and only) file\n\n    $pending-&gt;usingName('Profile Photo')\n        -&gt;toAssetCollection(ProfilePhotos::class)\n        -&gt;store();\n\n    return $this-&gt;response-&gt;setJSON(['pending_id' =&gt; $pending-&gt;id]);\n}</code></pre></p> <p>Example - Multiple files in one field: <pre><code>// HTML: &lt;input type=\"file\" name=\"documents[]\" multiple&gt;\n\n// Process all uploaded documents\n$result = PendingAsset::createFromRequest('documents');\n\nforeach ($result['documents'] as $pending) {\n    $pending-&gt;setOrder($index++)\n        -&gt;withCustomProperty('uploaded_by', auth()-&gt;id())\n        -&gt;store();\n\n    $pendingIds[] = $pending-&gt;id;\n}\n\nreturn $this-&gt;response-&gt;setJSON(['pending_ids' =&gt; $pendingIds]);</code></pre></p> <p>Example - Multiple different fields: <pre><code>// HTML:\n// &lt;input type=\"file\" name=\"avatar\"&gt;\n// &lt;input type=\"file\" name=\"cover\"&gt;\n// &lt;input type=\"file\" name=\"documents[]\" multiple&gt;\n\n// Process only avatar and cover, ignore documents\n$result = PendingAsset::createFromRequest('avatar', 'cover');\n\nif (!empty($result['avatar'])) {\n    $avatarPending = $result['avatar'][0];\n    $avatarPending-&gt;usingName('User Avatar')-&gt;store();\n}\n\nif (!empty($result['cover'])) {\n    $coverPending = $result['cover'][0];\n    $coverPending-&gt;usingName('Cover Photo')-&gt;store();\n}</code></pre></p>"},{"location":"pending/#setting-metadata","title":"Setting Metadata","text":"<p>Pending asset supports a fluent interface for setting metadata:</p> <pre><code>$pending = PendingAsset::createFromFile('/path/to/photo.jpg');\n\n$pending-&gt;usingName('Profile Picture')\n    -&gt;usingFileName('profile.jpg')\n    -&gt;setOrder(1)\n    -&gt;preservingOriginal(true)\n    -&gt;withCustomProperty('alt', 'Image description')\n    -&gt;withCustomProperty('caption', 'My profile picture')\n    -&gt;withCustomProperties([\n        'photographer' =&gt; 'John Doe',\n        'location' =&gt; 'Zagreb'\n    ]);</code></pre>"},{"location":"pending/#storing-pending-assets","title":"Storing Pending Assets","text":"<p>The <code>store()</code> method is used to save pending assets. It automatically handles both creating new pending assets and updating metadata of existing ones.</p>"},{"location":"pending/#basic-store-example","title":"Basic Store Example","text":"<pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAsset;\n\n// Create pending asset\n$pending = PendingAsset::createFromFile('/path/to/photo.jpg');\n$pending-&gt;usingName('My Photo');\n\n// Store (automatically generates ID)\n$pending-&gt;store();\n\n// ID is now available\n$pendingId = $pending-&gt;id; // e.g., \"a1b2c3d4e5f6789012345678\"\n\n// Return ID to client/front-end\nreturn $this-&gt;response-&gt;setJSON(['pending_id' =&gt; $pendingId]);</code></pre>"},{"location":"pending/#store-with-custom-ttl","title":"Store with Custom TTL","text":"<pre><code>$pending = PendingAsset::createFromFile('/path/to/document.pdf');\n\n// Store with 1 hour TTL instead of default 24 hours\n$pending-&gt;store(null, 3600);\n\necho \"Pending ID: \" . $pending-&gt;id;</code></pre>"},{"location":"pending/#update-metadata-store-with-existing-id","title":"Update Metadata (Store with Existing ID)","text":"<pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAssetManager;\n\n// Fetch existing pending asset\n$pending = PendingAssetManager::make()-&gt;fetchById($existingId);\n\nif ($pending) {\n    // Update metadata\n    $pending-&gt;withCustomProperty('status', 'reviewed');\n    $pending-&gt;usingName('Updated Name');\n\n    // Store - only updates metadata.json, file remains unchanged\n    $pending-&gt;store();\n}</code></pre> <p>Note: For complete <code>PendingAssetManager</code> API documentation (fetching, deleting, cleaning), see Pending Asset Manager.</p>"},{"location":"pending/#create-vs-update-important","title":"Create vs Update (Important!)","text":"<p>One of the key characteristics of pending storage is the distinction between creating a new asset and updating metadata of an existing asset.</p>"},{"location":"pending/#create-new-creation","title":"Create (new creation)","text":"<p>When a pending asset does not have an ID, <code>store()</code> will: 1. Generate a new unique ID 2. Store the raw file in <code>WRITEPATH/assets_pending/&lt;id&gt;/file</code> 3. Store metadata in <code>WRITEPATH/assets_pending/&lt;id&gt;/metadata.json</code></p> <pre><code>$pending = PendingAsset::createFromFile('/path/to/photo.jpg');\n// $pending-&gt;id is an empty string \"\"\n\n$pending-&gt;store();\n// Now $pending-&gt;id has a value like \"a1b2c3d4e5f6\"</code></pre>"},{"location":"pending/#update-metadata-only-update","title":"Update (metadata-only update)","text":"<p>When a pending asset has an ID, <code>store()</code> will: 1. Update only <code>metadata.json</code> 2. WILL NOT overwrite the existing <code>file</code> on disk</p> <pre><code>// Fetch existing pending asset\n$pending = PendingAssetManager::make()-&gt;fetchById('a1b2c3d4e5f6');\n\n// Change metadata\n$pending-&gt;withCustomProperty('caption', 'New caption');\n$pending-&gt;usingName('Changed name');\n\n// Store - updates only metadata.json\n$pending-&gt;store();\n\n// Raw file remains identical!</code></pre> <p>Important note: If you want to replace the file for an existing pending ID: 1. First delete the old pending asset: <code>$manager-&gt;deleteById($id)</code> 2. Create a new pending asset and store it: <code>$manager-&gt;store($newPending)</code></p>"},{"location":"pending/#adding-pending-assets-to-an-entity-addassetfrompending","title":"Adding Pending Assets to an Entity: addAssetFromPending","text":"<p>The <code>addAssetFromPending</code> method allows easy conversion of a pending asset into a real asset attached to an entity.</p>"},{"location":"pending/#method-signature","title":"Method Signature","text":"<pre><code>public function addAssetFromPending(\n    PendingAsset|string $pendingAsset,\n    ?PendingStorageInterface $storage = null\n): AssetAdder</code></pre> <p>Parameters: - <code>$pendingAsset</code> - PendingAsset object or pending asset ID (string) - <code>$storage</code> - Optional custom pending storage (null uses default)</p> <p>Returns: <code>AssetAdder</code> object for further configuration and saving</p>"},{"location":"pending/#how-does-it-work","title":"How does it work?","text":"<p>The <code>addAssetFromPending</code> method:</p> <ol> <li>If you pass a string (ID), fetches the <code>PendingAsset</code> using <code>PendingAssetManager::fetchById()</code></li> <li>If the pending asset is not found or has expired, throws <code>AssetException::forPendingAssetNotFound()</code></li> <li>Creates an <code>AssetAdder</code> using the actual file from the pending asset (<code>$pendingAsset-&gt;file</code>)</li> <li>Automatically transfers all metadata from the pending asset:</li> <li><code>usingName()</code> - display name</li> <li><code>usingFileName()</code> - file name</li> <li><code>setOrder()</code> - order</li> <li><code>withCustomProperties()</code> - all custom properties</li> <li><code>preservingOriginal()</code> - preserve original</li> <li>Returns the <code>AssetAdder</code> which you can further configure (e.g., set collection) and save</li> </ol> <p>Note: Pending assets are automatically cleaned up from storage after being successfully added to an entity.</p>"},{"location":"pending/#usage-examples","title":"Usage Examples","text":""},{"location":"pending/#1-basic-adding-with-id","title":"1. Basic adding with ID","text":"<pre><code>// In controller after user confirms upload\npublic function confirmUpload()\n{\n    $pendingId = $this-&gt;request-&gt;getPost('pending_id');\n\n    // Get user\n    $user = model(UserModel::class)-&gt;find($userId);\n\n    // Add asset from pending\n    $user-&gt;addAssetFromPending($pendingId)\n        -&gt;toAssetCollection(ProfilePhotos::class);\n\n\n    return $this-&gt;response-&gt;setJSON(['success' =&gt; true]);\n}</code></pre>"},{"location":"pending/#2-adding-with-pendingasset-object","title":"2. Adding with PendingAsset object","text":"<pre><code>$manager = PendingAssetManager::make();\n$pending = $manager-&gt;fetchById($pendingId);\n\nif (!$pending) {\n    throw new \\RuntimeException('Pending asset not found');\n}\n\n// Check something before adding\nif ($pending-&gt;size &gt; 5 * 1024 * 1024) {\n    throw new \\RuntimeException('File is too large');\n}\n\n// Add asset\n$user-&gt;addAssetFromPending($pending)\n    -&gt;toAssetCollection(Documents::class);</code></pre>"},{"location":"pending/#3-additional-configuration-before-saving","title":"3. Additional configuration before saving","text":"<pre><code>$assetAdder = $user-&gt;addAssetFromPending($pendingId);\n\n// Override some properties from pending\n$assetAdder-&gt;usingName('New Title')\n    -&gt;withCustomProperty('verified', true)\n    -&gt;toAssetCollection(Images::class);\n</code></pre>"},{"location":"pending/#4-working-with-multiple-pending-assets","title":"4. Working with multiple pending assets","text":"<pre><code>$pendingIds = $this-&gt;request-&gt;getPost('pending_ids'); // ['id1', 'id2', 'id3']\n\n$manager = PendingAssetManager::make();\n\nforeach ($pendingIds as $pendingId) {\n    try {\n        $product-&gt;addAssetFromPending($pendingId)\n            -&gt;toAssetCollection(ProductImages::class);\n    } catch (\\Exception $e) {\n        log_message('error', 'Failed to add pending asset: ' . $e-&gt;getMessage());\n    }\n}</code></pre>"},{"location":"pending/#5-custom-pending-storage","title":"5. Custom pending storage","text":"<pre><code>use App\\CustomPendingStorage;\n\n$customStorage = new CustomPendingStorage();\n\n$user-&gt;addAssetFromPending($pendingId, $customStorage)\n    -&gt;toAssetCollection(Avatars::class);</code></pre>"},{"location":"pending/#complete-example-upload-flow-with-front-end","title":"Complete Example: Upload Flow with Front-end","text":""},{"location":"pending/#backend-upload-endpoint","title":"Backend: Upload endpoint","text":"<pre><code>// app/Controllers/Upload.php\npublic function uploadPending()\n{\n    try {\n        // Create pending asset from request using 'file' field\n        $result = PendingAsset::createFromRequest('file');\n\n        if (empty($result['file'])) {\n            return $this-&gt;response-&gt;setStatusCode(400)\n                -&gt;setJSON(['error' =&gt; 'No file uploaded']);\n        }\n\n        $pending = $result['file'][0];\n\n        // Set additional metadata\n        $pending-&gt;usingName($this-&gt;request-&gt;getPost('name') ?? $pending-&gt;file_name)\n            -&gt;withCustomProperty('user_id', auth()-&gt;id());\n\n        // Store in pending storage\n        $pending-&gt;store();\n\n        // Return ID to client\n        return $this-&gt;response-&gt;setJSON([\n            'success' =&gt; true,\n            'pending_id' =&gt; $pending-&gt;id,\n            'file_name' =&gt; $pending-&gt;file_name,\n            'size' =&gt; $pending-&gt;size\n        ]);\n\n    } catch (\\Exception $e) {\n        return $this-&gt;response-&gt;setStatusCode(400)\n            -&gt;setJSON(['error' =&gt; $e-&gt;getMessage()]);\n    }\n}</code></pre>"},{"location":"pending/#backend-confirm-endpoint","title":"Backend: Confirm endpoint","text":"<pre><code>// app/Controllers/Upload.php\npublic function confirmPending()\n{\n    $pendingId = $this-&gt;request-&gt;getPost('pending_id');\n    $userId = auth()-&gt;id();\n\n    $user = model(UserModel::class)-&gt;find($userId);\n\n    try {\n        // Add asset from pending\n        $user-&gt;addAssetFromPending($pendingId)\n            -&gt;withCustomProperty('confirmed_at', date('Y-m-d H:i:s'))\n            -&gt;toAssetCollection(ProfilePhotos::class);\n\n\n        return $this-&gt;response-&gt;setJSON([\n            'success' =&gt; true,\n            'message' =&gt; 'Asset added successfully'\n        ]);\n    } catch (\\Exception $e) {\n        return $this-&gt;response-&gt;setStatusCode(400)\n            -&gt;setJSON([\n                'success' =&gt; false,\n                'error' =&gt; $e-&gt;getMessage()\n            ]);\n    }\n}</code></pre>"},{"location":"pending/#frontend-javascript-code","title":"Frontend: JavaScript code","text":"<pre><code>// Upload file\nasync function uploadFile(file) {\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('name', file.name);\n\n    const response = await fetch('/upload/pending', {\n        method: 'POST',\n        body: formData\n    });\n\n    const data = await response.json();\n\n    if (data.success) {\n        console.log('Pending ID:', data.pending_id);\n        return data.pending_id;\n    }\n}\n\n// Confirm upload\nasync function confirmUpload(pendingId) {\n    const response = await fetch('/upload/confirm-pending', {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify({pending_id: pendingId})\n    });\n\n    const data = await response.json();\n    return data.success;\n}\n\n// Usage\ndocument.getElementById('file-input').addEventListener('change', async (e) =&gt; {\n    const file = e.target.files[0];\n    const pendingId = await uploadFile(file);\n\n    // User can review, edit metadata, etc.\n    // Then confirm upload\n    if (confirm('Add this file?')) {\n        await confirmUpload(pendingId);\n        alert('File added successfully!');\n    }\n});</code></pre>"},{"location":"pending/#updating-metadata-without-replacing-the-file","title":"Updating Metadata Without Replacing the File","text":"<p>An important characteristic of pending storage is the ability to update metadata without overwriting the file.</p>"},{"location":"pending/#example-editing-metadata","title":"Example: Editing metadata","text":"<pre><code>// User first uploads file\n$pending = PendingAsset::createFromFile($_FILES['photo']['tmp_name']);\n$pending-&gt;store();\n\n$pendingId = $pending-&gt;id;\n// Return ID to front-end\n\n// Later user edits metadata (e.g., adds alt text, caption)\n$pending = PendingAssetManager::make()-&gt;fetchById($pendingId);\n$pending-&gt;withCustomProperty('alt', 'Beautiful sunset')\n    -&gt;withCustomProperty('caption', 'Sunset in Croatia')\n    -&gt;usingName('Sunset Photo');\n\n// Save - only metadata.json is updated, file remains the same\n$pending-&gt;store();</code></pre>"},{"location":"pending/#phpunit-test-verify-that-file-remains-unchanged","title":"PHPUnit test: Verify that file remains unchanged","text":"<pre><code>public function testUpdatingPendingMetadataDoesNotOverwriteFile()\n{\n    // Create and store pending asset\n    $originalContent = 'original file contents';\n    $pending = PendingAsset::createFromString($originalContent);\n    $pending-&gt;withCustomProperty('version', 1);\n\n    $pending-&gt;store();\n    $id = $pending-&gt;id;\n\n    // Check file checksum\n    $filePath = WRITEPATH . 'assets_pending' . DIRECTORY_SEPARATOR . $id . DIRECTORY_SEPARATOR . 'file';\n    $this-&gt;assertFileExists($filePath);\n    $checksumBefore = md5_file($filePath);\n\n    // Update only metadata\n    $pending-&gt;withCustomProperty('version', 2);\n    $pending-&gt;usingName('Updated name');\n    $pending-&gt;store();\n\n    // Re-fetch and verify metadata\n    $reloaded = PendingAssetManager::make()-&gt;fetchById($id);\n    $this-&gt;assertNotNull($reloaded);\n    $this-&gt;assertEquals(2, $reloaded-&gt;custom_properties['version']);\n    $this-&gt;assertEquals('Updated name', $reloaded-&gt;name);\n\n    // Verify file is identical\n    $checksumAfter = md5_file($filePath);\n    $this-&gt;assertEquals($checksumBefore, $checksumAfter);\n\n    // Verify content is actually the same\n    $this-&gt;assertEquals($originalContent, file_get_contents($filePath));\n}</code></pre>"},{"location":"pending/#advanced-usage","title":"Advanced Usage","text":"<p>For advanced topics including custom storage implementations (S3, Redis, etc.), see:</p> <ul> <li>Custom Pending Storage - Implementing custom storage backends</li> </ul>"},{"location":"pending/#troubleshooting","title":"Troubleshooting","text":""},{"location":"pending/#fetchbyid-returns-null","title":"<code>fetchById()</code> returns <code>null</code>","text":"<p>Possible causes:</p> <ol> <li>Asset has expired - check if <code>created_at + ttl &lt; now</code></li> <li>ID doesn't exist - check if directory <code>WRITEPATH/assets_pending/&lt;id&gt;</code> was created</li> <li>Corrupted metadata - check if <code>metadata.json</code> is valid JSON</li> <li>Missing file - check if <code>file</code> exists in the directory</li> </ol> <p>Verification: <pre><code>$id = 'a1b2c3d4e5f6';\n$basePath = WRITEPATH . 'assets_pending' . DIRECTORY_SEPARATOR . $id . DIRECTORY_SEPARATOR;\n\nif (!is_dir($basePath)) {\n    echo \"Directory does not exist\";\n} elseif (!file_exists($basePath . 'file')) {\n    echo \"File does not exist\";\n} elseif (!file_exists($basePath . 'metadata.json')) {\n    echo \"Metadata does not exist\";\n} else {\n    $metadata = json_decode(file_get_contents($basePath . 'metadata.json'), true);\n    print_r($metadata);\n}</code></pre></p>"},{"location":"pending/#assetexceptionforpendingassetnotfound","title":"<code>AssetException::forPendingAssetNotFound()</code>","text":"<p>This error is thrown when: - <code>addAssetFromPending()</code> receives an ID that doesn't exist or has expired</p> <p>Solution: <pre><code>try {\n    $user-&gt;addAssetFromPending($pendingId)\n        -&gt;toAssetCollection(Images::class);\n} catch (AssetException $e) {\n    // Notify user that asset has expired\n    return $this-&gt;response-&gt;setStatusCode(404)\n        -&gt;setJSON(['error' =&gt; 'Pending asset not found or expired. Please upload again.']);\n}</code></pre></p>"},{"location":"pending/#disk-space-issues","title":"Disk space issues","text":"<p>Pending assets take up space. Ensure regular cleanup:</p> <pre><code>// Run daily in cron\n$manager = PendingAssetManager::make();\n$manager-&gt;cleanExpiredPendingAssets();</code></pre>"},{"location":"pending/#permissions-issues","title":"Permissions issues","text":"<p>Ensure <code>WRITEPATH/assets_pending/</code> has correct permissions:</p> <pre><code>chmod -R 755 writable/assets_pending\nchown -R www-data:www-data writable/assets_pending</code></pre>"},{"location":"pending/#summary","title":"Summary","text":"<ul> <li>Pending assets enable temporary storage of files before final attachment to an entity</li> <li>TTL (default 24h) automatically deletes old pending assets</li> <li>Create vs Update: if pending has an ID, <code>store()</code> updates only metadata without overwriting the file</li> <li><code>addAssetFromPending()</code> converts a pending asset into a real asset - simple and fast</li> <li>Automatic cleanup: pending assets are automatically removed from storage after successful addition to an entity</li> <li>Expired assets cleanup: expired pending assets are automatically cleaned up by the <code>AssetConnectJob</code> queue job when processing assets</li> </ul> <p>Pending assets make upload processes more flexible and allow users to first upload a file, then edit metadata, and finally confirm where the asset will be added.</p>"},{"location":"pending/#security-tokens","title":"Security Tokens","text":"<p>Pending assets support security tokens to verify and control access to pending assets.</p>"},{"location":"pending/#what-are-security-tokens","title":"What are Security Tokens?","text":"<p>Security tokens are short-lived tokens that ensure only authorized actions are performed on pending assets. They prevent misuse of pending asset IDs and allow validating requests from the client.</p>"},{"location":"pending/#usage-pattern","title":"Usage pattern","text":"<ol> <li> <p>Token generation is automatic when you store a pending asset via <code>PendingAsset::store()</code> (which delegates to <code>PendingAssetManager::store()</code>). The manager will:</p> </li> <li> <p>Generate a pending ID (when creating a new pending asset)</p> </li> <li>Persist the pending file/metadata using the configured pending storage</li> <li>Invoke the configured token provider's <code>generateToken($pendingId)</code> and set the resulting token on the <code>PendingAsset</code> instance (<code>$pending-&gt;security_token</code>).</li> </ol> <p>Therefore you do NOT need to instantiate the token provider or call <code>generateToken()</code> manually in typical flows. Example:</p> <pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAsset;\n\n$result = PendingAsset::createFromRequest('file');\n$pending = $result['file'][0];\n\n// Persist pending asset - the PendingAssetManager will generate and persist the token\n$pending-&gt;store();\n\n// After storing, the token is available on the PendingAsset object (if a token provider is configured)\nreturn $this-&gt;response-&gt;setJSON([\n    'pending_id' =&gt; $pending-&gt;id,\n    'security_token' =&gt; $pending-&gt;security_token,\n]);</code></pre> <ol> <li> <p>Token validation / retrieval behavior</p> </li> <li> <p><code>PendingSecurityTokenInterface::validateToken(PendingAsset $pendingAsset, ?string $tokenProvided = null): bool</code> validates the provided token against the pending asset's stored <code>security_token</code>.</p> </li> <li>If you don't pass a <code>$tokenProvided</code>, most built-in token providers (the abstract implementation) will automatically call <code>retrieveToken($pendingId)</code> and validate the retrieved value. For example, <code>SessionPendingSecurityToken::retrieveToken()</code> reads the token from session tempdata.</li> </ol> <p>Example \u2014 validating a token that the client passed explicitly:</p> <pre><code>use Maniaba\\AssetConnect\\Pending\\PendingAssetManager;\nuse Maniaba\\AssetConnect\\Pending\\PendingSecurityToken\\SessionPendingSecurityToken;\n\n$manager = PendingAssetManager::make();\n$pending = $manager-&gt;fetchById($pendingId);\n\nif (! $pending) {\n    throw new \\RuntimeException('Pending asset not found');\n}\n\n// Validate by passing the token explicitly into fetchById().\n// If token is invalid the method returns null.\n$pending = $manager-&gt;fetchById($pendingId, $providedTokenFromClient);\n\nif ($pending === null) {\n    // Either asset not found, expired, or invalid token\n    throw new \\RuntimeException('Pending asset not found or invalid security token.');\n}\n\n// proceed to convert pending asset into a real asset</code></pre> <p>Example \u2014 let the provider retrieve the token itself (no explicit token passed):</p> <pre><code>$pending = $manager-&gt;fetchById($pendingId);\n\nif ($pending === null) {\n    // Asset not found, expired, or provider failed to validate token\n    throw new \\RuntimeException('Pending asset not found or invalid/expired token.');\n}\n\n// proceed to convert pending asset into a real asset</code></pre> <p>Notes:</p> <ul> <li>Token validation is executed inside <code>PendingAssetManager::fetchById(string $id, ?string $token = null): ?PendingAsset</code>. If the token provider is configured, <code>fetchById()</code> will call the provider's <code>validateToken()</code> internally. When validation fails <code>fetchById()</code> returns <code>null</code>.</li> <li>You can explicitly pass the token into <code>fetchById()</code> (useful when the client sends token in the request body). If you omit the token, the configured provider will usually attempt <code>retrieveToken($pendingId)</code> itself (for example, <code>SessionPendingSecurityToken</code> reads session tempdata).</li> <li>If <code>Config\\Asset::$pendingSecurityToken</code> is <code>null</code>, token generation and validation are disabled and <code>fetchById()</code> will behave like a normal read (subject to expiration checks).</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This page provides solutions to common issues you might encounter when using CodeIgniter Asset Connect.</p>"},{"location":"troubleshooting/#having-issues","title":"Having Issues?","text":"<p>If you're experiencing issues with CodeIgniter Asset Connect, you can:</p> <ol> <li>Check the CodeIgniter logs in <code>writable/logs/</code> for more detailed error information.</li> <li>Enable debug mode in your application to get more detailed error messages.</li> <li>Open an issue on the GitHub repository with a detailed description of your problem and steps to reproduce it.</li> </ol>"},{"location":"validation/","title":"Validation","text":"<p>This page covers validation of file uploads in your application using the <code>AssetConnectValidator</code> class. This class works together with the <code>ValidationRuleCollector</code> to generate validation rules based on asset collection definitions and validate data against these rules.</p>"},{"location":"validation/#overview","title":"Overview","text":"<p>The <code>AssetConnectValidator</code> class provides a flexible way to validate file uploads by:</p> <ol> <li>Generating validation rules from asset collection definitions</li> <li>Supporting validation of multiple fields with different collection definitions</li> <li>Providing methods to validate data against these rules</li> <li>Supporting validation directly from HTTP requests</li> </ol>"},{"location":"validation/#basic-usage","title":"Basic Usage","text":"<pre><code>// Get a collection definition\n$collectionDefinition = new YourCollectionDefinition();\n\n// Create a validator\n$validator = new \\Maniaba\\AssetConnect\\Validation\\AssetConnectValidator($collectionDefinition);\n\n// Set a field collection definition (required)\n$validator-&gt;setFieldCollectionDefinition('file', $collectionDefinition);\n\n// Validate data\n$data = [\n    'file' =&gt; $this-&gt;request-&gt;getFile('upload')\n];\n\nif ($validator-&gt;validate($data)) {\n    // Validation passed\n    // Process the file\n} else {\n    // Validation failed\n    $errors = $validator-&gt;getErrors();\n    // Handle errors\n}</code></pre>"},{"location":"validation/#defining-field-names","title":"Defining Field Names","text":"<p>You must define field names using the <code>setFieldCollectionDefinition</code> method:</p> <pre><code>// Create a validator\n$validator = new \\Maniaba\\AssetConnect\\Validation\\AssetConnectValidator($collectionDefinition);\n\n// Define a field name\n$validator-&gt;setFieldCollectionDefinition('upload_file', $collectionDefinition);\n\n// Now your data should use this field name\n$data = [\n    'upload_file' =&gt; $this-&gt;request-&gt;getFile('upload')\n];\n\nif ($validator-&gt;validate($data)) {\n    // Validation passed\n}</code></pre> <p>This allows you to have multiple file uploads with different field names.</p>"},{"location":"validation/#using-different-collection-definitions-for-different-fields","title":"Using Different Collection Definitions for Different Fields","text":"<p>You can set different collection definitions for different fields using the <code>setFieldCollectionDefinition</code> method:</p> <pre><code>// Create a validator\n$validator = new \\Maniaba\\AssetConnect\\Validation\\AssetConnectValidator(\n    new DefaultCollectionDefinition()\n);\n\n// Set collection definitions for fields\n$validator-&gt;setFieldCollectionDefinition('file1', new DefaultCollectionDefinition());\n$validator-&gt;setFieldCollectionDefinition('file2', new DefaultCollectionDefinition());\n$validator-&gt;setFieldCollectionDefinition('testfile', new NewCollectionDefinition());\n\n// Validate data\n$data = [\n    'file1' =&gt; $this-&gt;request-&gt;getFile('upload1'),\n    'file2' =&gt; $this-&gt;request-&gt;getFile('upload2'),\n    'testfile' =&gt; $this-&gt;request-&gt;getFile('test')\n];\n\nif ($validator-&gt;validate($data)) {\n    // Validation passed for all fields\n    // Process the files\n} else {\n    // Validation failed\n    $errors = $validator-&gt;getErrors();\n    // Handle errors\n}</code></pre> <p>This approach allows you to use a single validator instance for multiple fields, each with its own collection definition.</p>"},{"location":"validation/#validating-specific-fields","title":"Validating Specific Fields","text":"<p>You can validate specific fields instead of all fields:</p> <pre><code>if ($validator-&gt;validateFields($data, 'file')) {\n    // Validation passed for the 'file' field\n    // Process the file\n}</code></pre>"},{"location":"validation/#validating-all-defined-fields","title":"Validating All Defined Fields","text":"<p>After setting up field collection definitions with <code>setFieldCollectionDefinition</code>, you can validate all defined fields without having to specify them again:</p> <pre><code>// Create a validator\n$validator = new \\Maniaba\\AssetConnect\\Validation\\AssetConnectValidator(\n    new DefaultCollectionDefinition()\n);\n\n// Set collection definitions for fields\n$validator-&gt;setFieldCollectionDefinition('file1', new DefaultCollectionDefinition());\n$validator-&gt;setFieldCollectionDefinition('file2', new DefaultCollectionDefinition());\n$validator-&gt;setFieldCollectionDefinition('testfile', new NewCollectionDefinition());\n\n// Validate all defined fields (file1, file2, testfile)\n$data = [\n    'file1' =&gt; $this-&gt;request-&gt;getFile('upload1'),\n    'file2' =&gt; $this-&gt;request-&gt;getFile('upload2'),\n    'testfile' =&gt; $this-&gt;request-&gt;getFile('test')\n];\n\nif ($validator-&gt;validateDefinedFields($data)) {\n    // Validation passed for all defined fields\n    // Process the files\n} else {\n    // Validation failed\n    $errors = $validator-&gt;getErrors();\n    // Handle errors\n}</code></pre> <p>You can also get the names of all defined fields:</p> <pre><code>$fieldNames = $validator-&gt;getDefinedFieldNames(); // Returns ['file1', 'file2', 'testfile']</code></pre> <p>And get the validation rules for all defined fields:</p> <pre><code>$definedFieldRules = $validator-&gt;getRulesForDefinedFields();</code></pre>"},{"location":"validation/#validating-fields-from-request","title":"Validating Fields from Request","text":"<p>You can validate fields directly from the request using CodeIgniter's <code>withRequest</code> method:</p> <pre><code>if ($validator-&gt;validateFieldsFromRequest('file1', 'profilePicture')) {\n    // Validation passed for 'file1' and 'profilePicture' from the request\n    // Process the files\n}</code></pre> <p>This method uses CodeIgniter's validation with the request data directly, which simplifies the validation process. It gets the rules for the specified fields and applies them to the request data.</p> <p>For multiple file uploads, you can still specify the field names as you would with other validation methods:</p> <pre><code>if ($validator-&gt;validateFieldsFromRequest('file1', 'documents')) {\n    // Validation passed for 'file1' and 'documents' from the request\n    // Process the files\n}</code></pre>"},{"location":"validation/#validating-all-defined-fields-from-request","title":"Validating All Defined Fields from Request","text":"<p>Similar to <code>validateDefinedFields</code>, you can validate all defined fields directly from the request without having to specify them again:</p> <pre><code>if ($validator-&gt;validateDefinedFieldsFromRequest()) {\n    // Validation passed for all defined fields from the request\n    // Process the files\n} else {\n    // Validation failed\n    $errors = $validator-&gt;getErrors();\n    // Handle errors\n}</code></pre> <p>This is particularly useful when you've already defined your fields with <code>setFieldCollectionDefinition</code> and don't want to repeat the field names when validating.</p>"},{"location":"validation/#getting-validation-rules-and-errors","title":"Getting Validation Rules and Errors","text":"<p>You can get all validation rules or rules for specific fields:</p> <pre><code>// Get all rules\n$allRules = $validator-&gt;getRules();\n\n// Get rules for specific fields\n$fileRules = $validator-&gt;getRulesForFields('file');\n\n// Get rules for all defined fields\n$definedFieldRules = $validator-&gt;getRulesForDefinedFields();\n\n// Get validation errors\n$errors = $validator-&gt;getErrors();</code></pre> <p>The <code>getRules()</code> method returns CodeIgniter 4 compatible validation rules for the current validator instance. This is particularly useful when you want to combine AssetConnectValidator rules with additional validation rules for other fields in your form and continue validation using CodeIgniter 4's validator.</p>"},{"location":"validation/#example-combining-with-codeigniter-4-validator","title":"Example: Combining with CodeIgniter 4 Validator","text":"<pre><code>// Create AssetConnectValidator and set up rules for file uploads\n$fileValidator = new \\Maniaba\\AssetConnect\\Validation\\AssetConnectValidator();\n$fileValidator-&gt;setFieldCollectionDefinition('profile_image', new ProfileImageCollection());\n\n// Get the rules generated by AssetConnectValidator\n$fileRules = $fileValidator-&gt;getRules();\n\n// Create a standard CodeIgniter validator with additional rules\n$validation = \\Config\\Services::validation();\n$validation-&gt;setRules([\n    // Add file upload rules from AssetConnectValidator\n    ...$fileRules,\n\n    // Add additional rules for other form fields\n    'username' =&gt; 'required|min_length[5]|max_length[50]',\n    'email' =&gt; 'required|valid_email',\n    'age' =&gt; 'required|integer|greater_than[17]'\n]);\n\n// Run validation on all fields together\nif ($validation-&gt;withRequest($this-&gt;request)-&gt;run()) {\n    // All validation passed (both files and other fields)\n    // Process the form data\n} else {\n    // Validation failed\n    $errors = $validation-&gt;getErrors();\n    // Handle errors\n}</code></pre> <p>This approach allows you to seamlessly integrate file validation with other form field validations in your application.</p>"},{"location":"validation/#example-with-a-collection-definition","title":"Example with a Collection Definition","text":"<p>Here's an example of how validation rules are generated from a collection definition:</p> <pre><code>class ImagesCollection implements AssetCollectionDefinitionInterface, AssetVariantsInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition\n            -&gt;allowedExtensions(AssetExtension::JPG, AssetExtension::PNG, AssetExtension::GIF)\n            -&gt;allowedMimeTypes(AssetMimeType::IMAGE_JPEG, AssetMimeType::IMAGE_PNG, AssetMimeType::IMAGE_GIF)\n            -&gt;setMaxFileSize(2 * 1024 * 1024) // 2MB\n            -&gt;singleFileCollection();\n    }\n\n    // ... other methods\n}</code></pre> <p>When you set this collection definition for a field, the generated validation rules would be:</p> <pre><code>// For field name 'image'\n[\n    'image' =&gt; 'uploaded[image]|ext_in[image,jpg,png,gif]|mime_in[image,image/jpeg,image/png,image/gif]|max_size[image,2048]|max_file_count[1]'\n]</code></pre>"},{"location":"validation/#validating-multiple-fields-with-different-collection-definitions","title":"Validating Multiple Fields with Different Collection Definitions","text":"<p>As shown in the previous section, you can use the <code>CollectionValidator</code> class to validate multiple fields with different collection definitions:</p> <pre><code>// Create a validator\n$validator = new \\Maniaba\\AssetConnect\\Validation\\AssetConnectValidator(\n    new ImagesCollection()\n);\n\n// Set collection definitions for fields\n$validator-&gt;setFieldCollectionDefinition('file1', new ImagesCollection());\n$validator-&gt;setFieldCollectionDefinition('multipleFileCollection', new DocumentsCollection());\n$validator-&gt;setFieldCollectionDefinition('profilePicture', new AvatarCollection());\n\n// Validate data\n$data = [\n    'file1' =&gt; $this-&gt;request-&gt;getFile('upload1'),\n    'multipleFileCollection' =&gt; $this-&gt;request-&gt;getFileMultiple('documents'),\n    'profilePicture' =&gt; $this-&gt;request-&gt;getFile('avatar')\n];\n\nif ($validator-&gt;validate($data)) {\n    // Validation passed for all fields\n    // Process the files\n} else {\n    // Validation failed\n    $errors = $validator-&gt;getErrors();\n    // Handle errors\n}</code></pre> <p>You can also validate specific fields:</p> <pre><code>if ($validator-&gt;validateFields($data, 'file1', 'profilePicture')) {\n    // Validation passed for 'file1' and 'profilePicture'\n    // Process these files\n}</code></pre> <p>And get rules for specific fields:</p> <pre><code>$file1Rules = $validator-&gt;getRulesForFields('file1');</code></pre>"},{"location":"validation/#legacy-approach-multifieldcollectionvalidator","title":"Legacy Approach: MultiFieldCollectionValidator","text":"<p>For backward compatibility, the <code>MultiFieldCollectionValidator</code> class is still available, but using the enhanced <code>CollectionValidator</code> class as shown above is the recommended approach:</p> <pre><code>// Create a multi-field validator\n$multiValidator = new \\Maniaba\\AssetConnect\\Validation\\MultiFieldCollectionValidator();\n\n// Add fields with their respective collection definitions\n$multiValidator-&gt;addField('file1', new ImagesCollection());\n$multiValidator-&gt;addField('multipleFileCollection', new DocumentsCollection());\n$multiValidator-&gt;addField('profilePicture', new AvatarCollection());\n\n// Validate data\n$data = [\n    'file1' =&gt; $this-&gt;request-&gt;getFile('upload1'),\n    'multipleFileCollection' =&gt; $this-&gt;request-&gt;getFileMultiple('documents'),\n    'profilePicture' =&gt; $this-&gt;request-&gt;getFile('avatar')\n];\n\nif ($multiValidator-&gt;validate($data)) {\n    // Validation passed for all fields\n    // Process the files\n} else {\n    // Validation failed\n    $errors = $multiValidator-&gt;getErrors();\n    // Handle errors\n}</code></pre>"},{"location":"validation/#working-with-validationrulecollector","title":"Working with ValidationRuleCollector","text":"<p>The <code>ValidationRuleCollector</code> class is used internally by <code>AssetConnectValidator</code> to collect validation rules from asset collection definitions. It implements the <code>AssetCollectionSetterInterface</code> and provides methods to set various validation constraints.</p>"},{"location":"validation/#how-they-work-together","title":"How They Work Together","text":"<ol> <li><code>AssetConnectValidator</code> creates a <code>ValidationRuleCollector</code> for each field</li> <li>The collection definition's <code>definition()</code> method is called with the rule collector</li> <li>The rule collector collects validation rules based on the methods called on it</li> <li><code>AssetConnectValidator</code> retrieves the collected rules and uses them for validation</li> </ol>"},{"location":"validation/#validationrulecollector-methods","title":"ValidationRuleCollector Methods","text":"<p>The <code>ValidationRuleCollector</code> provides the following methods for setting validation constraints:</p>"},{"location":"validation/#file-validation","title":"File Validation","text":"<ul> <li><code>allowedExtensions(AssetExtension|string ...$extensions)</code>: Validates file extensions</li> <li><code>allowedMimeTypes(AssetMimeType|string ...$mimeTypes)</code>: Validates MIME types</li> <li><code>setMaxFileSize(float|int $maxFileSize)</code>: Validates maximum file size</li> <li><code>singleFileCollection()</code>: Ensures only a single file is uploaded</li> <li><code>onlyKeepLatest(int $maximumNumberOfItemsInCollection)</code>: Limits the number of files</li> </ul>"},{"location":"validation/#image-validation","title":"Image Validation","text":"<ul> <li><code>setMaxImageDimensions(int $width, int $height)</code>: Validates maximum image dimensions</li> <li><code>setMinImageDimensions(int $width, int $height)</code>: Validates minimum image dimensions</li> <li><code>requireImage()</code>: Ensures the file is an image</li> </ul>"},{"location":"validation/#advanced-usage","title":"Advanced Usage","text":""},{"location":"validation/#validating-multiple-file-uploads","title":"Validating Multiple File Uploads","text":"<p>For multiple file uploads, you can use the <code>onlyKeepLatest</code> method to limit the number of files:</p> <pre><code>class MultipleImagesCollection implements AssetCollectionDefinitionInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition\n            -&gt;allowedExtensions(AssetExtension::JPG, AssetExtension::PNG)\n            -&gt;allowedMimeTypes(AssetMimeType::IMAGE_JPEG, AssetMimeType::IMAGE_PNG)\n            -&gt;setMaxFileSize(2 * 1024 * 1024) // 2MB\n            -&gt;requireImage()\n            -&gt;onlyKeepLatest(5); // Allow up to 5 images\n    }\n}</code></pre> <p>Then validate as usual:</p> <pre><code>$validator-&gt;setFieldCollectionDefinition('gallery_images', new MultipleImagesCollection());\n\nif ($validator-&gt;validateFieldsFromRequest('gallery_images')) {\n    $images = $this-&gt;request-&gt;getFileMultiple('gallery_images');\n    // Process the images\n}</code></pre>"},{"location":"validation/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing how to use <code>AssetConnectValidator</code> with multiple fields and different collection definitions:</p> <pre><code>// Define collection definitions\nclass ProfileImageCollection implements AssetCollectionDefinitionInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition\n            -&gt;allowedExtensions(AssetExtension::JPG, AssetExtension::PNG)\n            -&gt;allowedMimeTypes(AssetMimeType::IMAGE_JPEG, AssetMimeType::IMAGE_PNG)\n            -&gt;setMaxFileSize(1 * 1024 * 1024) // 1MB\n            -&gt;setMaxImageDimensions(500, 500)\n            -&gt;requireImage()\n            -&gt;singleFileCollection();\n    }\n}\n\nclass DocumentsCollection implements AssetCollectionDefinitionInterface\n{\n    public function definition(AssetCollectionSetterInterface $definition): void\n    {\n        $definition\n            -&gt;allowedExtensions(AssetExtension::PDF, AssetExtension::DOC, AssetExtension::DOCX)\n            -&gt;allowedMimeTypes(\n                AssetMimeType::APPLICATION_PDF,\n                AssetMimeType::APPLICATION_MSWORD,\n                AssetMimeType::APPLICATION_DOCX\n            )\n            -&gt;setMaxFileSize(5 * 1024 * 1024) // 5MB\n            -&gt;onlyKeepLatest(3); // Allow up to 3 documents\n    }\n}\n\n// In your controller\npublic function upload()\n{\n    // Create a validator\n    $validator = new \\Maniaba\\AssetConnect\\Validation\\AssetConnectValidator();\n\n    // Set field collection definitions\n    $validator-&gt;setFieldCollectionDefinition('profile_image', new ProfileImageCollection());\n    $validator-&gt;setFieldCollectionDefinition('documents', new DocumentsCollection());\n\n    // Validate from request\n    if ($validator-&gt;validateRequest()) {\n        // Validation passed\n\n        // Get the files\n        $profileImage = $this-&gt;request-&gt;getFile('profile_image');\n        $documents = $this-&gt;request-&gt;getFileMultiple('documents');\n\n        // Process the files\n        // ...\n\n        return redirect()-&gt;to('/success')-&gt;with('message', 'Files uploaded successfully');\n    } else {\n        // Validation failed\n        $errors = $validator-&gt;getErrors();\n\n        return redirect()-&gt;back()-&gt;withInput()-&gt;with('errors', $errors);\n    }\n}</code></pre>"}]}